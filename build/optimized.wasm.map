{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","~lib/rt/pure.ts","~lib/rt/tlsf.ts","~lib/bindings/wasi_snapshot_preview1.ts","~lib/as-wasi/as-wasi.ts","~lib/util/number.ts","~lib/util/string.ts","~lib/string.ts","~lib/memory.ts","~lib/util/memory.ts","~lib/number.ts","~lib/arraybuffer.ts","~lib/gc.ts","~lib/rt.ts","~lib/util/error.ts","~lib/builtins.ts","~lib/array.ts","assembly/index.ts"],"names":[],"mappings":"mYE4GE,AAAO,AAAC,AADG,cACwB,AAAC,EAAO,0BAC3C,EAAW,EAAO,MAElB,AAAoB,KAAW,qBA+J/B,AAAI,EAAM,MAAa,AAAU,AAAkB,EAAM,WAOzD,AAAI,EAAM,MAAa,AAAU,AAAkB,EAAM,SMhPvD,AAAO,AAAkB,EAA0B,MAA0B,SCV7E,EAAkB,ICuHpB,AAAI,ADvHM,EAAK,KC8Hf,AAAI,EAAO,KACT,AACM,AAAC,EAAM,GAAO,EAAO,QACvB,AAAO,EAAO,KACZ,AAAI,AAAC,KACL,AAAE,OACQ,SAAiB,SAA3B,AAAU,EAAQ,AAAS,cAE7B,AAAO,EAAK,KACV,AAAW,EAAM,AAAU,QAC3B,EAAQ,KACR,EAAQ,KACR,EAAQ,YAId,IACY,SAAiB,SAA3B,AAAU,EAAQ,AAAS,QAC3B,AAAE,YAGJ,AACM,AAAC,EAAM,GAAO,EAAO,QACvB,AAAO,AAAC,EAAO,GAAK,KAClB,AAAI,AAAC,KACL,AAAU,AAAO,AAAE,OAAT,GAAY,AAAS,EAAM,eAEvC,AAAO,EAAK,KAEV,AAAW,AAAO,AADlB,EAAK,KACM,GAAU,AAAU,EAAM,gBAI3C,IACE,AAAU,AAAO,AAAE,OAAT,GAAY,AAAS,EAAM,oBFxHvC,AAAI,SAAwB,wBAI5B,AAAI,AADiB,AAFC,IAAe,KAEL,AADT,IAAgB,eAEd,OAEzB,AAAY,AADF,AAA2B,EAAS,QACV,EAAyB,IAC7D,AAAY,EAAyB,GAAU,EAA0B,aAXlE,EAAqB,GAA4B,GAAsB,OFgDrE,AAAY,EAAG,EAAG,EAAQ,IAG1B,AAAY,EAAG,AADF,EAAG,EAAG,EAAQ,MACT,EAAQ,KAJ/B,EAAQ,KAQH,AAAY,EAAG,EAAG,EAAQ,MAG1B,AAAY,EAAG,AADF,EAAG,EAAI,EAAQ,QACV,EAAQ,OAJ/B,EAAQ,OARV,EAAQ,aA6GV,AAAQ,EAAM,KAId,AAAW,EAAU,AADrB,EAAU,KACqB,IAAI,AAAc,AAHnC,EAAM,GAGe,MAFnC,AAAM,YA2BR,AAAI,AAAC,KAAc,KAKnB,AAtBc,AAoBJ,AAAQ,AADH,AAAe,MACA,GAAG,MApBX,EAAK,IAuBpB,gCEiYH,AAAa,AADA,EACS,AAAO,AAAkB,EAAyB,WAEjE,EAAS,KAEV,AADK,AAAe,OACf,MAGP,EAAU,IACD,EAAK,MACd,EAAU,IAEV,AAA+B,EAAS,GAAI,KAAxC,AAAC,EAAK,KAAW,QACnB,AAAI,AAAC,AAAe,KAAa,KAAW,OAC1C,EAAU,KAAG,EAAU,SAI3B,EAAU,OAEZ,EAAU,iBAOZ,AAAa,AADA,IACyB,AAAO,AAAkB,EAAyB,SAGxF,AAAa,AADH,AAAQ,AADL,AAAuB,MACV,MACP,KACnB,AAAa,MACb,AAAO,EAAS,KAEV,AADK,AAAe,OACf,MACP,AAAU,EAAQ,KAClB,MACS,EAAK,MAGd,AAAW,EAAQ,AAAU,AAFpB,EAAM,GAAI,IAEA,AADV,EAAK,GAAK,IACM,OACzB,EAAU,IAEV,AAA+B,EAAS,GAAI,KAAxC,AAAC,EAAK,KAAW,QAEnB,AAAI,AAAC,AADI,AAAe,OACd,KAAW,OAKnB,AAAS,AAJJ,AAAW,AAAC,EAAK,IAAW,GAA5B,KAAmC,EAAK,OAIzB,GAAK,MACzB,AAAW,EAAQ,AAAgC,AAJ1C,EAAM,GAAK,IAID,EAAM,GAAK,AAFrB,EAAM,GAAK,GAAK,IAEW,IAAK,AAHhC,EAAM,GAAK,GAAK,IAGsB,QAC/C,EAAU,KAAG,EAAU,SAO3B,AAAW,EAAQ,AAAU,AAHpB,EAAM,GAAK,IAGD,AAFV,EAAM,GAAK,GAAK,IAEA,OACzB,AAAU,EAAQ,AAFT,EAAW,GAAK,OAGzB,EAAU,OAEZ,EAAU,SAEZ,AAAO,EAAU,mBAIV,SItoBT,AAAO,AAAkB,AP0QR,AAAmB,MO1Qe,QP8QnD,AAAW,AADD,QACM,KAChB,AAAW,EAAK,KAGhB,AAAU,AADD,QACK,KACd,AAAW,EAAK,KAChB,AAAW,EAAM,KAIjB,AAAS,KAAY,EAAK,EAAG,AADX,gBAlClB,AACE,EAAmB,SAguBrB,EAAW,OAAM,ACntBR,AAAO,UDmtByB,OAAM,ACntBtC,AAAO,UDmtByD,OAAc,MAtOvF,AA/rB4B,AAAsB,MA+rBlB,QAwOlC,AAAU,2CFhwBV,AAAkB,AADF,OACc,oBAE9B,AAAkB,AADP,EAAY,KACG,KAAiB,EAAO,4BAalD,AAAkB,AATlB,AAAI,EAAO,MAET,AAAK,AAAM,EAAQ,KADd,GAKL,AAAK,AAAO,EAAS,AADhB,EAAM,AAAW,MACI,IAAa,KACvC,EAAM,MAEe,KAAW,EAAK,wBAIvC,AAAW,OACX,AAAI,AAFO,SAED,EAAY,MACtB,AAAI,IAAM,EAAY,MAGtB,AAAI,EAAS,AApIX,EAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,UAqI5D,AA5HA,EAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,IAC5D,KA8HA,AAAI,AAAC,KAEH,AApJF,EAA2B,EAAM,IACjC,AAXF,AACE,EAA2B,EAAM,OA6JN,AAAE,EAAK,YAGhC,AAAI,AAAC,KAAO,OAAc,AAAE,EAAK,mBAzGrC,AAAkB,mBAElB,AAAkB,AADF,OACc,oBAM9B,AAAI,AAHY,AADJ,qBAII,KAEd,AAAI,AADU,AAAC,EAAY,GAAc,GAAkB,EAAY,MACzD,SACZ,AAAY,EAAM,IAClB,EAAe,AAAY,AAA0B,EAAzB,EAAY,SAE5B,AADJ,AArHa,EAA2B,GAAkB,KAAe,aA4HrF,AAAI,EAAY,KAGd,AAAkB,AADH,AADJ,AAnIM,EAA2B,aAqIf,oBAE7B,AAAI,AADU,AAAC,EAAW,GAAc,GAAkB,EAAY,MACxD,WACZ,AAAY,EAAM,IAClB,EAAc,AAAY,AAAyB,EAAxB,EAAW,SAC9B,OAKZ,EAAe,EAAY,MAK3B,AAAkB,AADP,EAAY,KACG,KAAiB,EAAO,4BAClD,AAAkB,AAA4C,EAA5C,EAA2B,IAAyB,mBAGtE,AAAa,EAA2B,GAAiB,KAazD,AAAkB,AATlB,AAAI,EAAO,MAET,AAAK,AAAM,EAAQ,KADd,GAKL,AAAK,AAAO,EAAS,AADhB,EAAM,AAAW,MACI,IAAa,KACvC,EAAM,MAEe,KAAW,EAAK,wBA5FvC,AACE,EAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,SA+F9D,EAAa,KACb,EAFW,KAGX,AAAI,IAAM,EAAY,MACtB,AAzFE,EAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,IAC5D,KA2FF,OAAe,EAAK,OACpB,AAhHE,EAA2B,EAAM,IACjC,AA+Gc,AAzHd,EAA2B,EAAM,OAyHA,EAAK,aAkHxC,AAII,AAAE,EAAM,MADR,AAAE,EAAQ,MADV,EAAS,sBAQb,AAAI,AAFO,AA7MT,UAgNA,AAAkB,EAAS,EAA0B,oBAGrD,AAAI,AAA0B,EAA1B,EAAQ,MAEV,AAAW,OADX,EAAS,OAON,AACE,EAAS,EAA0B,sBAK5C,AAAI,AADO,EAAM,YAQjB,EAAc,AAAmB,EAAW,GAA9B,AAFC,EAAQ,GAEE,OACzB,EAAY,KACZ,EAAY,KAIZ,AADO,AAAkB,EAAQ,GAAO,KAC1B,KACd,AAtOE,EACA,MAuOF,AAAY,EAAM,UAmClB,AAAI,AAAC,AADM,OAKT,AAAI,AADc,EACA,AAFA,OAEe,AAAY,EAAc,KAAe,SAAG,EAE7E,AADO,KACM,KACb,GAAc,OACU,EAAK,KAC3B,SAAgB,KACX,AAAc,MAAG,EAAK,KACzB,eAAsB,KADY,AAAE,WAFF,AAAE,WAM9B,GAAM,GAA+C,EAAiB,KAChF,AAAO,WAtBT,AAAI,EAAQ,SAA+B,eACzB,AAAC,EAAO,GAAW,mBAxHrC,AAAkB,AAdlB,AAAI,EAAO,MAET,AAAK,AAAM,EAAQ,KADd,GAMa,EAAO,SACrB,EAAQ,EAAM,EAAW,AAAW,MAAU,MAGlD,AAAK,AAAO,EAAgB,AADvB,EAAM,AAHO,MAIe,IAAa,KAC9C,EAAM,MAEe,KAAW,EAAK,wBAKvC,AAAK,AAFO,WAAmB,EAAM,QAc5B,AA1LP,EAA2B,AAAC,AAAkB,AA0LZ,GA1LL,EAAM,IAAyB,QAiL5D,AAAK,AADO,KAAc,EAAO,EAAK,SAMpC,AAAkB,AADV,AAxMV,EAA2B,AAuMpB,AAAW,KAvMe,0BA0MxB,EAAkB,AAAS,iBAL3B,SAqGX,AAAI,AAAY,AAJhB,AAAkB,IAElB,AAAkB,AAAO,AAAC,AADlB,EAAkB,AAAqD,AAjQ7E,MAiQ8B,AAAC,EAAsB,GAAM,KAP7D,AAEE,EAAQ,AAAC,EAAM,EAAW,AAAW,KAAU,MAF7C,EAAO,SAQsB,KAAU,KAAa,aAEzB,KAC7B,AAAI,AAAY,IAAe,KAAG,GAG1B,EAAM,EAAsB,GAAI,EAAqB,WAxF/D,AAAgB,OAChB,AAAoB,EAAO,mBAI3B,AAAI,AADY,AAAC,EAAY,GAAc,UAEzC,EAAe,EAAQ,EAAY,OAGnC,AADY,AAA8D,EAA5C,EAA2B,MAC1C,AAAC,EAAY,GAAkB,MAC9C,AAAY,EAAM,KAIlB,EAAe,EAAY,MAC3B,AAtRuB,EAA2B,GAAkB,KAAe,IAsRnF,iBAA0B,aA+G5B,AAAmB,kBAGnB,AAAI,AAAC,AADO,AAAY,EAAM,AADZ,AAAY,aAI1B,AAAyB,IAEzB,AAAyB,IAEzB,AAAI,AAAC,AADG,AAAY,EAAM,SAExB,AAAW,EAAM,IAEjB,AAAkB,AADV,AAA8B,EAAM,yBASlD,AAAkB,AAAC,QAA8B,mBACjD,EAAe,KACf,EAAa,KACb,EAAe,KACf,AAAY,EAAM,IAClB,AAAa,EAAM,EAAc,SAkEjC,AAAO,AACS,EAAmB,EAAM,IACrC,QW3hBJ,AAAa,AAHD,AAAQ,EAAmB,MAGnB,AAAS,AADhB,AAAQ,EAAY,WAEjC,AAAa,EAAO,KACpB,AAAW,EAAO,KAClB,AAAW,EAAO,KAClB,AAAsB,EAAQ,GAAM,YL3BlC,ECsLA,AAAI,ADtLW,KCuLf,AAAU,EAAM,KAChB,AAAU,EAAO,GAAI,GAAG,KACxB,AAAI,EAAK,KAET,AAAU,EAAO,GAAG,KACpB,AAAU,EAAO,GAAG,KACpB,AAAU,EAAO,KAAI,GAAG,KACxB,AAAU,EAAW,GAAG,KACxB,AAAI,EAAK,KACT,AAAU,EAAO,GAAG,KACpB,AAAU,EAAO,GAAI,GAAG,KACxB,AAAI,EAAK,KAKT,EAAK,AAFU,EAAC,GAAO,QAQvB,AAAW,AAPX,EAAQ,KAOS,KACjB,AAAW,EAAO,AANlB,EAAK,MAMiB,GAAG,KACzB,AAAI,EAAK,KACT,AAAW,EAAO,GAAG,KACrB,AAAW,EAAO,GAAG,KACrB,AAAW,EAAO,KAAI,GAAI,KAC1B,AAAW,EAAW,GAAG,KACzB,AAAI,EAAK,KACT,AAAW,EAAO,GAAI,KACtB,AAAW,EAAO,GAAI,KACtB,AAAW,EAAO,GAAI,KACtB,AAAW,EAAO,GAAI,KACtB,AAAW,EAAO,KAAI,GAAI,KAC1B,AAAW,EAAW,GAAI,KAC1B,AAAW,EAAW,GAAI,KAC1B,AAAW,EAAW,GAAI,KAI1B,EAAQ,AADJ,AAAM,EAAO,GAAb,QAEJ,EAAK,OAIL,AAAO,EAAK,KACV,AAAW,EAAM,KACjB,AAAW,EAAO,GAAG,KACrB,AAAW,EAAO,GAAI,KACtB,AAAW,EAAO,GAAI,KACtB,EAAK,KACL,EAAQ,eE1MV,AAAI,EAAc,SAAyC,cAE3D,AAAY,AADC,AAAQ,EAAe,MACb,IAChB,STggBT,AAAY,AAAkB,EAAM,KACpC,AACc,AAAE,EAAM,MAApB,KACA,AAAE,KAAe,UACjB,AAAE,uCAXJ,EAAe,AADC,KACW,MAC3B,AAAY,EAAM,UArClB,AAAI,AAJc,AAAY,MAIV,AAHJ,aAId,AAAa,EAAM,EAAO,IAC1B,EAAe,KACR,IAMT,AAAI,AADY,AADJ,AAhba,EAA2B,GAAkB,KAAe,WAkbrE,KAEd,AAAI,AADY,AAAC,KAA0B,GAAkB,EAAY,MACxD,KACf,AAAY,EAAM,IAGlB,EAAe,AAAC,EAAY,GAAa,MACzC,EAAe,KACf,AAAa,EAAM,EAAO,IACnB,KAMX,AADe,AAAc,EAAM,EAAM,SACvB,QAClB,AAAY,EAA8B,GAAgB,EAA2B,GAAgB,IACrG,AAAI,EAA4B,MAE9B,AAAU,EAAM,UAmClB,AAAO,AACW,EAAmB,AAAe,IAAM,IACtD,SKgIA,AAAO,AADM,AADA,EACM,SACF,mBAEjB,AAAa,AADH,AAAQ,EAAU,UAErB,EAAS,KAAhB,EACE,AAAS,AAAc,OAAS,AAAE,OAClC,AAAM,EAAK,MAKT,AAAI,AAAU,EAAV,KACJ,AAAS,AAAc,KAAU,KAAI,AAAE,OACvC,AAAI,AAAC,EAAK,IAAQ,MAChB,AAAW,EAAQ,AAAiB,EAAjB,AAAC,EAAK,GAAO,QAEhC,AAAI,AAAU,EAAV,KACJ,AAAS,AAAc,KAAU,KAAI,AAAE,OACvC,AAAI,AAAC,EAAK,IAAQ,MAChB,AAAK,AAA4B,EAA5B,AAAC,EAAK,GAAO,GAAK,EAAM,QAE7B,AAAI,AAAU,EAAV,KACJ,AAAK,AAAsC,AAAc,KAAU,GAA9D,AAAC,EAAK,GAAM,GAAK,EAAM,IAAK,EAAM,OACvC,AAAE,QAEJ,AAAI,EAAK,OACP,AAAW,EAAQ,MAKnB,AAAW,EAAQ,AAFV,AADT,EAAM,OACS,GAAK,KAEK,AADf,EAAK,IAAU,KACM,OAC/B,EAAU,QAxBd,AAAI,AAAkB,KACtB,AAAW,EAAQ,MA2BrB,EAAU,UAEL,AAA6B,EAAK,EAAS,YSvuBtD,AAAI,EAAU,AADI,OACmB,MACnC,AAAI,EAAU,SAAkD,cAIhE,AAAY,AAAU,EAAV,AADE,AAAU,AAFV,AAAkB,OAEC,AADf,EAAW,UAES,EAAc,KACpD,AAAI,EAAY,KACd,AAAa,EAAO,KACpB,AAAa,EAAO,MAEtB,AAAW,EAAO,WAqLlB,AAAW,EAAyB,AADpB,AADH,OACY,OAEzB,AACe,KAAkB,EAAiB,IAAe,AAAS,OAI1E,EAAe,0BZ8tBH,aAAZ,OAIA,AAAI,AADqB,AADJ,QACoB,EAAiB,YAExD,aAGF,AAAY,AAAY,OACxB,AAAe,AACG,AAAC,AAHP,AAAY,OAGG,GAAK,SAGhC,AAAI,AAAS,EAAU,AADqB,eAE1C,AA+Ec,GACC,GACD,EACE,KAhFb,AAAe,MAAG,EAAI,KAEzB,AAAU,AADI,AAAY,EAAW,EAAI,WAEzC,KAAe,QAHiB,0BA1KlC,AA7qB4B,AAAsB,MA6qBlB,WYzrBhC,AAAI,EAAc,AAAK,QAAmC,eAE1D,AAEQ,AAAC,AAOF,AAAQ,KAAkB,iBAPkB,sBCvFrD,AAAI,AD+CF,AAAO,ACjDiB,Abo8BjB,Aar8BS,YAGA,KAChB,AbyxBW,WarxBb,AbqxBa,AarxBD,uChByGZ,AAAS,AADE,OACK,SAEhB,AAAoB,KAAW,kBAC/B,AAAI,EAAM,KACR,AAAgB,EAAuB,KAErC,AAAoB,EAAO,sBAC3B,AAAU,EAAM,KASlB,AAAkB,EAAK,kBACvB,AACE,EAAW,AAA2B,EAAK,GAA/B,EAAO,mBAvEvB,AAAI,EAAM,QAGR,AAAU,AAAkB,EAAM,UewahC,AAAU,AADA,OACO,AAAO,KAAgB,QACxC,AAAO,EAAM,KAEX,AAAI,AADM,AAAY,SACb,AAAQ,KACjB,EAAO","sourceRoot":"./optimized.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags;\n  /** Base class id or `0` if none. */\n  base: u32;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `Set`. */\n  SET = 1 << 2,\n  /** Type is a `Map`. */\n  MAP = 1 << 3,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 4,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 5,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 6,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 7,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 8,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 9,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 10,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 11,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 12,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 13,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 14,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 15,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 16,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 17,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 18,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 19,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 20,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 21,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 22\n}\n","import { DEBUG, BLOCK_OVERHEAD } from \"rt/common\";\nimport { Block, freeBlock, ROOT } from \"rt/tlsf\";\nimport { TypeinfoFlags } from \"shared/typeinfo\";\nimport { onincrement, ondecrement, onfree, onalloc } from \"./rtrace\";\n\n/////////////////////////// A Pure Reference Counting Garbage Collector ///////////////////////////\n// see:     https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon03Pure.pdf\n\n// ╒══════════════════════ GC Info structure ══════════════════════╕\n// │  3                   2                   1                    │\n// │1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0│\n// ├─┼─┴─┴─┼─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │B│color│                     refCount                          │\n// └─┴─────┴───────────────────────────────────────────────────────┘\n// B: buffered\n\n// @ts-ignore: decorator\n@inline const BUFFERED_MASK: u32 = 1 << ((sizeof<u32>() * 8) - 1);\n// @ts-ignore: decorator\n@inline const COLOR_BITS = 3;\n// @ts-ignore: decorator\n@inline const COLOR_SHIFT: u32 = ctz(BUFFERED_MASK) - COLOR_BITS;\n// @ts-ignore: decorator\n@inline const COLOR_MASK: u32 = ((1 << COLOR_BITS) - 1) << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline export const REFCOUNT_MASK: u32 = (1 << COLOR_SHIFT) - 1;\n\n// ╒════════╤═══════════════════ Colors ═══════════════════════════╕\n// │ Color  │ Meaning                                              │\n// ├────────┼──────────────────────────────────────────────────────┤\n// │ BLACK  │ In use or free                                       │\n// │ GRAY   │ Possible member of cycle                             │\n// │ WHITE  │ Member of garbage cycle                              │\n// │ PURPLE │ Possible root of cycle                               │\n// │ RED    │ Candidate cycle undergoing Σ-computation *concurrent │\n// │ ORANGE │ Candidate cycle awaiting epoch boundary  *concurrent │\n// └────────┴──────────────────────────────────────────────────────┘\n// Acyclic detection has been decoupled, hence no GREEN.\n\n// @ts-ignore: decorator\n@inline const COLOR_BLACK: u32 = 0 << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline const COLOR_GRAY: u32 = 1 << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline const COLOR_WHITE: u32 = 2 << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline const COLOR_PURPLE: u32 = 3 << COLOR_SHIFT;\n// @ts-ignore: decorator\n// @inline const COLOR_RED: u32 = 4 << COLOR_SHIFT;\n// @ts-ignore: decorator\n// @inline const COLOR_ORANGE: u32 = 5 << COLOR_SHIFT;\n\n// @ts-ignore: decorator\n@inline const VISIT_DECREMENT = 1; // guard 0\n// @ts-ignore: decorator\n@inline const VISIT_MARKGRAY = 2;\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 3;\n// @ts-ignore: decorator\n@inline const VISIT_SCANBLACK = 4;\n// @ts-ignore: decorator\n@inline const VISIT_COLLECTWHITE = 5;\n\n// @ts-ignore: decorator\n@global @unsafe @lazy\nfunction __visit(ref: usize, cookie: i32): void {\n  if (ref < __heap_base) return;\n  if (isDefined(__GC_ALL_ACYCLIC)) {\n    if (DEBUG) assert(cookie == VISIT_DECREMENT);\n    decrement(changetype<Block>(ref - BLOCK_OVERHEAD));\n  } else {\n    let s = changetype<Block>(ref - BLOCK_OVERHEAD);\n    switch (cookie) {\n      case VISIT_DECREMENT: {\n        decrement(s);\n        break;\n      }\n      case VISIT_MARKGRAY: {\n        if (DEBUG) assert((s.gcInfo & REFCOUNT_MASK) > 0);\n        s.gcInfo = s.gcInfo - 1;\n        markGray(s);\n        break;\n      }\n      case VISIT_SCAN: {\n        scan(s);\n        break;\n      }\n      case VISIT_SCANBLACK: {\n        let info = s.gcInfo;\n        assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\n        s.gcInfo = info + 1;\n        if ((info & COLOR_MASK) != COLOR_BLACK) {\n          scanBlack(s);\n        }\n        break;\n      }\n      case VISIT_COLLECTWHITE: {\n        collectWhite(s);\n        break;\n      }\n      default: if (DEBUG) assert(false);\n    }\n  }\n}\n\n/** Increments the reference count of the specified block by one.*/\nfunction increment(s: Block): void {\n  var info = s.gcInfo;\n  assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\n  s.gcInfo = info + 1;\n  if (isDefined(ASC_RTRACE)) onincrement(s);\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\n}\n\n/** Decrements the reference count of the specified block by one, possibly freeing it. */\n// @ts-ignore: decorator\n@lazy\nfunction decrement(s: Block): void {\n  var info = s.gcInfo;\n  var rc = info & REFCOUNT_MASK;\n  if (isDefined(ASC_RTRACE)) ondecrement(s);\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\n  if (rc == 1) {\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_DECREMENT);\n    if (isDefined(__GC_ALL_ACYCLIC)) {\n      if (DEBUG) assert(!(info & BUFFERED_MASK));\n      freeBlock(ROOT, s);\n    } else {\n      if (!(info & BUFFERED_MASK)) {\n        freeBlock(ROOT, s);\n      } else {\n        s.gcInfo = BUFFERED_MASK | COLOR_BLACK | 0;\n      }\n    }\n  } else {\n    if (DEBUG) assert(rc > 0);\n    if (isDefined(__GC_ALL_ACYCLIC)) {\n      s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\n    } else {\n      if (!(__typeinfo(s.rtId) & TypeinfoFlags.ACYCLIC)) {\n        s.gcInfo = BUFFERED_MASK | COLOR_PURPLE | (rc - 1);\n        if (!(info & BUFFERED_MASK)) {\n          appendRoot(s);\n        }\n      } else {\n        s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\n      }\n    }\n  }\n}\n\n/** Buffer of possible roots. */\n// @ts-ignore: decorator\n@lazy var ROOTS: usize;\n/** Current absolute offset into the `ROOTS` buffer. */\n// @ts-ignore: decorator\n@lazy var CUR: usize = 0;\n/** Current absolute end offset into the `ROOTS` buffer. */\n// @ts-ignore: decorator\n@lazy var END: usize = 0;\n\n/** Appends a block to possible roots. */\nfunction appendRoot(s: Block): void {\n  var cur = CUR;\n  if (cur >= END) {\n    growRoots(); // TBD: either that or pick a default and force collection on overflow\n    cur = CUR;\n  }\n  store<Block>(cur, s);\n  CUR = cur + sizeof<usize>();\n}\n\n/** Grows the roots buffer if it ran full. */\nfunction growRoots(): void {\n  var oldRoots = ROOTS;\n  var oldSize = CUR - oldRoots;\n  var newSize = max(oldSize * 2, 64 << alignof<usize>());\n  var newRoots = __alloc(newSize, 0);\n  if (isDefined(ASC_RTRACE)) onfree(changetype<Block>(newRoots - BLOCK_OVERHEAD)); // neglect unmanaged\n  memory.copy(newRoots, oldRoots, oldSize);\n  if (oldRoots) {\n    if (isDefined(ASC_RTRACE)) onalloc(changetype<Block>(oldRoots - BLOCK_OVERHEAD)); // neglect unmanaged\n    __free(oldRoots);\n  }\n  ROOTS = newRoots;\n  CUR = newRoots + oldSize;\n  END = newRoots + newSize;\n}\n\n/** Collects cyclic garbage. */\n// @ts-ignore: decorator\n@global @unsafe @lazy\nexport function __collect(): void {\n  if (isDefined(__GC_ALL_ACYCLIC)) return;\n\n  // markRoots\n  var roots = ROOTS;\n  var cur = roots;\n  for (let pos = cur, end = CUR; pos < end; pos += sizeof<usize>()) {\n    let s = load<Block>(pos);\n    let info = s.gcInfo;\n    if ((info & COLOR_MASK) == COLOR_PURPLE && (info & REFCOUNT_MASK) > 0) {\n      markGray(s);\n      store<Block>(cur, s);\n      cur += sizeof<usize>();\n    } else {\n      if ((info & COLOR_MASK) == COLOR_BLACK && !(info & REFCOUNT_MASK)) {\n        freeBlock(ROOT, s);\n      } else {\n        s.gcInfo = info & ~BUFFERED_MASK;\n      }\n    }\n  }\n  CUR = cur;\n\n  // scanRoots\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\n    scan(load<Block>(pos));\n  }\n\n  // collectRoots\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\n    let s = load<Block>(pos);\n    s.gcInfo = s.gcInfo & ~BUFFERED_MASK;\n    collectWhite(s);\n  }\n  CUR = roots;\n}\n\n/** Marks a block as gray (possible member of cycle) during the collection phase. */\nfunction markGray(s: Block): void {\n  var info = s.gcInfo;\n  if ((info & COLOR_MASK) != COLOR_GRAY) {\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_GRAY;\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_MARKGRAY);\n  }\n}\n\n/** Scans a block during the collection phase, determining whether it is garbage or not. */\nfunction scan(s: Block): void {\n  var info = s.gcInfo;\n  if ((info & COLOR_MASK) == COLOR_GRAY) {\n    if ((info & REFCOUNT_MASK) > 0) {\n      scanBlack(s);\n    } else {\n      s.gcInfo = (info & ~COLOR_MASK) | COLOR_WHITE;\n      __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCAN);\n    }\n  }\n}\n\n/** Marks a block as black (in use) if it was found to be reachable during the collection phase. */\nfunction scanBlack(s: Block): void {\n  s.gcInfo = (s.gcInfo & ~COLOR_MASK) | COLOR_BLACK;\n  __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCANBLACK);\n}\n\n/** Collects all white (member of a garbage cycle) nodes when completing the collection phase.  */\nfunction collectWhite(s: Block): void {\n  var info = s.gcInfo;\n  if ((info & COLOR_MASK) == COLOR_WHITE && !(info & BUFFERED_MASK)) {\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_BLACK;\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_COLLECTWHITE);\n    freeBlock(ROOT, s);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __retain(ptr: usize): usize {\n  if (ptr > __heap_base) increment(changetype<Block>(ptr - BLOCK_OVERHEAD));\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __release(ptr: usize): void {\n  if (ptr > __heap_base) decrement(changetype<Block>(ptr - BLOCK_OVERHEAD));\n}\n","import { AL_BITS, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"rt/common\";\nimport { onfree, onalloc, onrealloc } from \"./rtrace\";\nimport { REFCOUNT_MASK } from \"./pure\";\n\n/////////////////////// The TLSF (Two-Level Segregate Fit) memory allocator ///////////////////////\n//                             see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: usize = 1 << <usize>SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\n// @ts-ignore: decorator\n@inline const SB_SIZE: usize = 1 << <usize>SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┼─┤ overhead   ┐\n// │                          size                           │0│L│F│ ◄─┐ info\n// ├─────────────────────────────────────────────────────────┴─┴─┴─┤   │\n// │                                                               │   │\n// │               ... additional runtime overhead ...             │   │\n// │                                                               │   │\n// ╞═══════════════════════════════════════════════════════════════╡   │      ┐ ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │    = 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ payload  ┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export var ROOT: Root;\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    let newSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (newSize < BLOCK_MAXSIZE) {\n      removeBlock(root, right);\n      block.mmInfo = blockInfo = (blockInfo & TAGS_MASK) | newSize;\n      right = GETRIGHT(block);\n      rightInfo = right.mmInfo;\n      // 'back' is set below\n    }\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    let newSize = (leftInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK);\n    if (newSize < BLOCK_MAXSIZE) {\n      removeBlock(root, left);\n      left.mmInfo = blockInfo = (leftInfo & TAGS_MASK) | newSize;\n      block = left;\n      // 'back' is set below\n    }\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    fl = inv - clz<usize>(size);\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  var head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be valid\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    fl = inv - clz<usize>(size);\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  var prev = block.prev;\n  var next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  var slMap = GETSL(root, fl) & (~0 << sl);\n  var head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(!(size & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) {\n    assert(\n      start <= end &&       // must be valid\n      !(start & AL_MASK) && // must be aligned\n      !(end & AL_MASK)      // must be aligned\n    );\n  }\n\n  var tail = GETTAIL(root);\n  var tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    if (start - BLOCK_OVERHEAD == changetype<usize>(tail)) {\n      start -= BLOCK_OVERHEAD;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  var size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  var leftSize = size - (BLOCK_OVERHEAD << 1);\n  var left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + size - BLOCK_OVERHEAD);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  var pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  var pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size >= BLOCK_MAXSIZE) throw new Error(\"allocation too large\");\n  return max<usize>((size + AL_MASK) & ~AL_MASK, BLOCK_MINSIZE); // align and ensure min size\n}\n\n/** Initilizes the root structure. */\nexport function maybeInitialize(): Root {\n  var root = ROOT;\n  if (!root) {\n    const rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n    if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n    root = changetype<Root>(rootOffset);\n    root.flMap = 0;\n    SETTAIL(root, changetype<Block>(0));\n    for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n      SETSL(root, fl, 0);\n      for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n        SETHEAD(root, fl, sl, null);\n      }\n    }\n    addMemory(root, (rootOffset + ROOT_SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\n    ROOT = root;\n  }\n  return root;\n}\n\n// @ts-ignore: decorator\n@lazy\nvar collectLock: bool = false;\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize, id: u32): Block {\n  if (DEBUG) assert(!collectLock); // must not allocate while collecting\n  var payloadSize = prepareSize(size);\n  var block = searchBlock(root, payloadSize);\n  if (!block) {\n    if (gc.auto) {\n      if (DEBUG) collectLock = true;\n      __collect();\n      if (DEBUG) collectLock = false;\n      block = searchBlock(root, payloadSize);\n      if (!block) {\n        growMemory(root, payloadSize);\n        block = changetype<Block>(searchBlock(root, payloadSize));\n        if (DEBUG) assert(block); // must be found now\n      }\n    } else {\n      growMemory(root, payloadSize);\n      block = changetype<Block>(searchBlock(root, payloadSize));\n      if (DEBUG) assert(block); // must be found now\n    }\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  block.gcInfo = 0; // RC=0\n  block.rtId = id;\n  block.rtSize = size;\n  removeBlock(root, <Block>block);\n  prepareBlock(root, <Block>block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(<Block>block);\n  return <Block>block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var blockInfo = block.mmInfo;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= (blockInfo & ~TAGS_MASK)) {\n    prepareBlock(root, block, payloadSize);\n    block.rtSize = size;\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      // TODO: this can yield an intermediate block larger than BLOCK_MAXSIZE, which\n      // is immediately split though. does this trigger any assertions / issues?\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      block.rtSize = size;\n      prepareBlock(root, block, payloadSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  var newBlock = allocateBlock(root, size, block.rtId); // may invalidate cached blockInfo\n  newBlock.gcInfo = block.gcInfo; // keep RC\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, size);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onrealloc(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  block.mmInfo = blockInfo | FREE;\n  insertBlock(root, block);\n  if (isDefined(ASC_RTRACE)) onfree(block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ref: usize): Block {\n  var block = changetype<Block>(ref - BLOCK_OVERHEAD);\n  assert(\n    ref != 0 && !(ref & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE) &&        // must be used\n    !(block.gcInfo & ~REFCOUNT_MASK) // not buffered or != BLACK\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize, id: u32): usize {\n  return changetype<usize>(\n    allocateBlock(maybeInitialize(), size, id)\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ref: usize, size: usize): usize {\n  return changetype<usize>(\n    reallocateBlock(maybeInitialize(), checkUsedBlock(ref), size)\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ref: usize): void {\n  freeBlock(maybeInitialize(), checkUsedBlock(ref));\n}\n","// Phase: wasi_snapshot_preview1\n// See: https://github.com/WebAssembly/WASI/tree/master/phases/snapshot/witx\n\n/* tslint:disable:max-line-length */\n\n// helper types to be more explicit\ntype char = u8;\ntype ptr<T> = usize; // all pointers are usize'd\ntype struct<T> = T;  // structs are references already in AS\n\n/** Read command-line argument data. */\nexport declare function args_get(\n  /** Input: Pointer to a buffer to write the argument pointers. */\n  argv: ptr<ptr<char>>,\n  /** Input: Pointer to a buffer to write the argument string data. */\n  argv_buf: ptr<char>\n): errno;\n\n/** Return command-line argument data sizes. */\nexport declare function args_sizes_get(\n  /** Output: Number of arguments. */\n  argc: ptr<usize>,\n  /** Output: Size of the argument string data. */\n  argv_buf_size: ptr<usize>\n): errno;\n\n/** Return the resolution of a clock. */\nexport declare function clock_res_get(\n  /** Input: The clock for which to return the resolution. */\n  clock: clockid,\n  /** Output: The resolution of the clock. */\n  resolution: ptr<timestamp>\n): errno;\n\n/** Return the time value of a clock. */\nexport declare function clock_time_get(\n  /** Input: Cock for which to return the time. */\n  clock: clockid,\n  /** Input: Maximum lag (exclusive) that the returned time value may have, compared to its actual value. */\n  precision: timestamp,\n  /** Output: Time value of the clock. */\n  time: ptr<timestamp>\n): errno;\n\n/** Read environment variable data. */\nexport declare function environ_get(\n  /** Input: Pointer to a buffer to write the environment variable pointers. */\n  environ: ptr<usize>,\n  /** Input: Pointer to a buffer to write the environment variable string data. */\n  environ_buf: usize\n): errno;\n\n/** Return command-line argument data sizes. */\nexport declare function environ_sizes_get(\n  /** Output: The number of environment variables. */\n  environ_count: ptr<usize>,\n  /** Output: The size of the environment variable string data. */\n  environ_buf_size: ptr<usize>\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\nexport declare function fd_advise(\n  /** Input: The file descriptor for the file for which to provide file advisory information. */\n  fd: fd,\n  /** Input: The offset within the file to which the advisory applies. */\n  offset: filesize,\n  /** Input: The length of the region to which the advisory applies. */\n  len: filesize,\n  /** Input: The advice. */\n  advice: advice\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\nexport declare function fd_allocate(\n  /** Input: The file descriptor for the file in which to allocate space. */\n  fd: fd,\n  /** Input: The offset at which to start the allocation. */\n  offset: filesize,\n  /** Input: The length of the area that is allocated. */\n  len: filesize\n): errno;\n\n/** Close a file descriptor. */\nexport declare function fd_close(\n  /** Input: The file descriptor to close. */\n  fd: fd\n): errno;\n\n/** Synchronize the data of a file to disk. */\nexport declare function fd_datasync(\n  /** Input: The file descriptor of the file to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Get the attributes of a file descriptor. */\nexport declare function fd_fdstat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file descriptor's attributes are stored. */\n  buf: struct<fdstat>\n): errno;\n\n/** Adjust the flags associated with a file descriptor. */\nexport declare function fd_fdstat_set_flags(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the file descriptor flags. */\n  flags: fdflags\n): errno;\n\n/** Adjust the rights associated with a file descriptor. */\nexport declare function fd_fdstat_set_rights(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_base: rights,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_inheriting: rights\n): errno;\n\n/** Return the attributes of an open file. */\nexport declare function fd_filestat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros. */\nexport declare function fd_filestat_set_size(\n  /** Input: A file descriptor for the file to adjust. */\n  fd: fd,\n  /** Input: The desired file size. */\n  size: filesize\n): errno;\n\n/** Adjust the timestamps of an open file or directory. */\nexport declare function fd_filestat_set_times(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Read from a file descriptor, without using and updating the file descriptor's offset. */\nexport declare function fd_pread(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors in which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors in which to store data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to read. */\n  offset: filesize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\nexport declare function fd_prestat_get(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: The buffer where the description is stored. */\n  buf: struct<prestat>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\nexport declare function fd_prestat_dir_name(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: Buffer into which to write the preopened directory name. */\n  path: ptr<char>,\n  /** Input: Length of the buffer into which to write the preopened directory name. */\n  path_len: usize\n): errno;\n\n/** Write to a file descriptor, without using and updating the file descriptor's offset. */\nexport declare function fd_pwrite(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to write. */\n  offset: filesize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/** Read from a file descriptor. */\nexport declare function fd_read(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors to which to store data. */\n  iovs_len: usize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Read directory entries from a directory. */\nexport declare function fd_readdir(\n  /** Input: Directory from which to read the directory entries. */\n  fd: fd,\n  /** Input: Buffer where directory entries are stored. */\n  buf: ptr<struct<dirent>>,\n  /** Input: Length of the buffer where directory entries are stored. */\n  buf_len: usize,\n  /** Input: Location within the directory to start reading. */\n  cookie: dircookie,\n  /** Output: Number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Atomically replace a file descriptor by renumbering another file descriptor. */\nexport declare function fd_renumber(\n  /** Input: The file descriptor to renumber. */\n  from: fd,\n  /** Input: The file descriptor to overwrite. */\n  to: fd\n): errno;\n\n/** Move the offset of a file descriptor. */\nexport declare function fd_seek(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The number of bytes to move. */\n  offset: filedelta,\n  /** Input: The base from which the offset is relative. */\n  whence: whence,\n  /** Output: The new offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Synchronize the data and metadata of a file to disk. */\nexport declare function fd_sync(\n  /** Input: The file descriptor of the file containing the data and metadata to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Return the current offset of a file descriptor. */\nexport declare function fd_tell(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Output: The current offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Write to a file descriptor. */\nexport declare function fd_write(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/* Create a directory. */\nexport declare function path_create_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path at which to create the directory. */\n  path: ptr<char>,\n  /** Input: The path at which to create the directory. */\n  path_len: usize\n): errno;\n\n/** Return the attributes of a file or directory. */\nexport declare function path_filestat_get(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to inspect. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to inspect. */\n  path_len: usize,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the timestamps of a file or directory. */\nexport declare function path_filestat_set_times(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to operate on. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to operate on. */\n  path_len: usize,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Create a hard link. */\nexport declare function path_link(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  old_flags: lookupflags,\n  /** Input: The source path from which to link. */\n  old_path: ptr<char>,\n  /** Input: The source path from which to link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path at which to create the hard link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the hard link. */\n  new_path_len: usize\n): errno;\n\n/** Open a file or directory. */\nexport declare function path_open(\n  /** Input: The working directory at which the resolution of the path starts. */\n  dirfd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  dirflags: lookupflags,\n  /** Input: The path of the file or directory to open. */\n  path: ptr<char>,\n  /** Input: The length of the path of the file or directory to open. */\n  path_len: usize,\n  /** Input: The method by which to open the file. */\n  oflags: oflags,\n  /** Input: The initial base rights that apply to operations using the file descriptor itself. */\n  fs_rights_base: rights,\n  /** Input: The initial inheriting rights that apply to file descriptors derived from it. */\n  fs_rights_inheriting: rights,\n  /** Input: The initial flags of the file descriptor. */\n  fs_flags: fdflags,\n  /** Output: The file descriptor of the file that has been opened. */\n  fd: ptr<fd>\n): errno;\n\n/** Read the contents of a symbolic link. */\nexport declare function path_readlink(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path of the symbolic link from which to read. */\n  path: ptr<char>,\n  /** Input: The length of the path of the symbolic link from which to read. */\n  path_len: usize,\n  /** Input: The buffer to which to write the contents of the symbolic link. */\n  buf: ptr<char>,\n  /** Input: The length of the buffer to which to write the contents of the symbolic link. */\n  buf_len: usize,\n  /** Output: The number of bytes placed in the buffer. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Remove a directory. */\nexport declare function path_remove_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a directory to remove. */\n  path: ptr<char>,\n  /** Input: The length of the path to a directory to remove. */\n  path_len: usize\n): errno;\n\n/** Rename a file or directory. */\nexport declare function path_rename(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: The source path of the file or directory to rename. */\n  old_path: ptr<char>,\n  /** Input: The length of the source path of the file or directory to rename. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path to which to rename the file or directory. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path to which to rename the file or directory. */\n  new_path_len: usize\n): errno;\n\n/** Create a symbolic link. */\nexport declare function path_symlink(\n  /** Input: The contents of the symbolic link. */\n  old_path: ptr<char>,\n  /** Input: The length of the contents of the symbolic link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The destination path at which to create the symbolic link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the symbolic link. */\n  new_path_len: usize\n): errno;\n\n/** Unlink a file. */\nexport declare function path_unlink_file(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a file to unlink. */\n  path: ptr<char>,\n  /** Input: The length of the path to a file to unlink. */\n  path_len: usize\n): errno;\n\n/** Concurrently poll for the occurrence of a set of events. */\nexport declare function poll_oneoff(\n  /** Input: The events to which to subscribe. */\n  in_: ptr<struct<subscription>>,\n  /** Input: The events that have occurred. */\n  out: ptr<struct<event>>,\n  /** Input: Both the number of subscriptions and events. */\n  nsubscriptions: usize,\n  /** Output: The number of events stored. */\n  nevents: ptr<usize>\n): errno;\n\n/** Terminate the process normally. An exit code of 0 indicates successful termination of the program. The meanings of other values is dependent on the environment. */\nexport declare function proc_exit(\n  /** Input: The exit code returned by the process. */\n  rval: u32\n): void;\n\n/** Send a signal to the process of the calling thread. */\nexport declare function proc_raise(\n  /** Input: The signal condition to trigger. */\n  sig: signal\n): errno;\n\n/** Write high-quality random data into a buffer. */\nexport declare function random_get(\n  /** Input: The buffer to fill with random data. */\n  buf: usize,\n  /** Input: The length of the buffer to fill with random data. */\n  buf_len: usize\n): errno;\n\n/** Temporarily yield execution of the calling thread. */\nexport declare function sched_yield(): errno;\n\n/** Receive a message from a socket. */\nexport declare function sock_recv(\n  /** Input: The socket on which to receive data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  ri_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to store data. */\n  ri_data_len: usize,\n  /** Input: Message flags. */\n  ri_flags: riflags,\n  /** Output: Number of bytes stored in `ri_data`. */\n  ro_datalen: ptr<usize>,\n  /** Output: Message flags. */\n  ro_flags: ptr<roflags>\n): errno;\n\n/** Send a message on a socket. */\nexport declare function sock_send(\n  /** Input: The socket on which to send data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to retrieve data */\n  si_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to retrieve data */\n  si_data_len: usize,\n  /** Input: Message flags. */\n  si_flags: siflags,\n  /** Output: Number of bytes transmitted. */\n  so_datalen: ptr<usize>\n): errno;\n\n/** Shut down socket send and receive channels. */\nexport declare function sock_shutdown(\n  /** Input: The socket on which to shutdown channels. */\n  sock: fd,\n  /** Input: Which channels on the socket to shut down. */\n  how: sdflags\n): errno;\n\n// === Types ======================================================================================\n\n/** File or memory access pattern advisory information. */\nexport namespace advice {\n  /** The application has no advice to give on its behavior with respect to the specified data. */\n  // @ts-ignore: decorator\n  @inline\n  export const NORMAL: advice = 0;\n  /** The application expects to access the specified data sequentially from lower offsets to higher offsets. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEQUENTIAL : advice = 1;\n  /** The application expects to access the specified data in a random order. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANDOM: advice = 2;\n  /** The application expects to access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const WILLNEED: advice = 3;\n  /** The application expects that it will not access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const DONTNEED: advice = 4;\n  /** The application expects to access the specified data once and then not reuse it thereafter. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOREUSE: advice = 5;\n}\nexport type advice = u8;\n\n/** Identifiers for clocks. */\nexport namespace clockid {\n  /** The clock measuring real time. Time value zero corresponds with 1970-01-01T00:00:00Z. */\n  // @ts-ignore: decorator\n  @inline\n  export const REALTIME: clockid = 0;\n  /** The store-wide monotonic clock. Absolute value has no meaning. */\n  // @ts-ignore: decorator\n  @inline\n  export const MONOTONIC: clockid = 1;\n  /** The CPU-time clock associated with the current process. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROCESS_CPUTIME_ID: clockid = 2;\n  /** The CPU-time clock associated with the current thread. */\n  // @ts-ignore: decorator\n  @inline\n  export const THREAD_CPUTIME_ID: clockid = 3;\n}\nexport type clockid = u32;\n\n/** Identifier for a device containing a file system. Can be used in combination with `inode` to uniquely identify a file or directory in the filesystem. */\nexport type device = u64;\n\n/** A reference to the offset of a directory entry. The value 0 signifies the start of the directory. */\nexport type dircookie = u64;\n\n/** A directory entry. */\n@unmanaged export class dirent {\n  /** The offset of the next directory entry stored in this directory. */\n  next: dircookie;\n  /** The serial number of the file referred to by this directory entry. */\n  ino: inode;\n  /** The length of the name of the directory entry. */\n  namlen: u32;\n  /** The type of the file referred to by this directory entry. */\n  type: filetype;\n  private __padding0: u16;\n}\n\n/** Error codes returned by functions. */\nexport namespace errno {\n  /** No error occurred. System call completed successfully. */\n  // @ts-ignore: decorator\n  @inline\n  export const SUCCESS: errno = 0;\n  /** Argument list too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const TOOBIG: errno = 1;\n  /** Permission denied. */\n  // @ts-ignore: decorator\n  @inline\n  export const ACCES: errno = 2;\n  /** Address in use. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRINUSE: errno = 3;\n  /** Address not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRNOTAVAIL: errno = 4;\n  /** Address family not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const AFNOSUPPORT: errno = 5;\n  /** Resource unavailable, or operation would block. */\n  // @ts-ignore: decorator\n  @inline\n  export const AGAIN: errno = 6;\n  /** Connection already in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALREADY: errno = 7;\n  /** Bad file descriptor. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADF: errno = 8;\n  /** Bad message. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADMSG: errno = 9;\n  /** Device or resource busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUSY: errno = 10;\n  /** Operation canceled. */\n  // @ts-ignore: decorator\n  @inline\n  export const CANCELED: errno = 11;\n  /** No child processes. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHILD: errno = 12;\n  /** Connection aborted. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNABORTED: errno = 13;\n  /** Connection refused. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNREFUSED: errno = 14;\n  /** Connection reset. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNRESET: errno = 15;\n  /** Resource deadlock would occur. */\n  // @ts-ignore: decorator\n  @inline\n  export const DEADLK: errno = 16;\n  /** Destination address required. */\n  // @ts-ignore: decorator\n  @inline\n  export const DESTADDRREQ: errno = 17;\n  /** Mathematics argument out of domain of function. */\n  // @ts-ignore: decorator\n  @inline\n  export const DOM: errno = 18;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const DQUOT: errno = 19;\n  /** File exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXIST: errno = 20;\n  /** Bad address. */\n  // @ts-ignore: decorator\n  @inline\n  export const FAULT: errno = 21;\n  /** File too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const FBIG: errno = 22;\n  /** Host is unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const HOSTUNREACH: errno = 23;\n  /** Identifier removed. */\n  // @ts-ignore: decorator\n  @inline\n  export const IDRM: errno = 24;\n  /** Illegal byte sequence. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILSEQ: errno = 25;\n  /** Operation in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const INPROGRESS: errno = 26;\n  /** Interrupted function. */\n  // @ts-ignore: decorator\n  @inline\n  export const INTR: errno = 27;\n  /** Invalid argument. */\n  // @ts-ignore: decorator\n  @inline\n  export const INVAL: errno = 28;\n  /** I/O error. */\n  // @ts-ignore: decorator\n  @inline\n  export const IO: errno = 29;\n  /** Socket is connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISCONN: errno = 30;\n  /** Is a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISDIR: errno = 31;\n  /** Too many levels of symbolic links. */\n  // @ts-ignore: decorator\n  @inline\n  export const LOOP: errno = 32;\n  /** File descriptor value too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MFILE: errno = 33;\n  /** Too many links. */\n  // @ts-ignore: decorator\n  @inline\n  export const MLINK: errno = 34;\n  /** Message too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MSGSIZE: errno = 35;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const MULTIHOP: errno = 36;\n  /** Filename too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const NAMETOOLONG: errno = 37;\n  /** Network is down. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETDOWN: errno = 38;\n  /** Connection aborted by network. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETRESET: errno = 39;\n  /** Network unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETUNREACH: errno = 40;\n  /** Too many files open in system. */\n  // @ts-ignore: decorator\n  @inline\n  export const NFILE: errno = 41;\n  /** No buffer space available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOBUFS: errno = 42;\n  /** No such device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NODEV: errno = 43;\n  /** No such file or directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOENT: errno = 44;\n  /** Executable file format error. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOEXEC: errno = 45;\n  /** No locks available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLCK: errno = 46;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLINK: errno = 47;\n  /** Not enough space. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMEM: errno = 48;\n  /** No message of the desired type. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMSG: errno = 49;\n  /** Protocol not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOPROTOOPT: errno = 50;\n  /** No space left on device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSPC: errno = 51;\n  /** Function not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSYS: errno = 52;\n  /** The socket is not connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCONN: errno = 53;\n  /** Not a directory or a symbolic link to a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTDIR: errno = 54;\n  /** Directory not empty. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTEMPTY: errno = 55;\n  /** State not recoverable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTRECOVERABLE: errno = 56;\n  /** Not a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSOCK: errno = 57;\n  /** Not supported, or operation not supported on socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSUP: errno = 58;\n  /** Inappropriate I/O control operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTTY: errno = 59;\n  /** No such device or address. */\n  // @ts-ignore: decorator\n  @inline\n  export const NXIO: errno = 60;\n  /** Value too large to be stored in data type. */\n  // @ts-ignore: decorator\n  @inline\n  export const OVERFLOW: errno = 61;\n  /** Previous owner died. */\n  // @ts-ignore: decorator\n  @inline\n  export const OWNERDEAD: errno = 62;\n  /** Operation not permitted. */\n  // @ts-ignore: decorator\n  @inline\n  export const PERM: errno = 63;\n  /** Broken pipe. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: errno = 64;\n  /** Protocol error. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTO: errno = 65;\n  /** Protocol not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTONOSUPPORT: errno = 66;\n  /** Protocol wrong type for socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTOTYPE: errno = 67;\n  /** Result too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANGE: errno = 68;\n  /** Read-only file system. */\n  // @ts-ignore: decorator\n  @inline\n  export const ROFS: errno = 69;\n  /** Invalid seek. */\n  // @ts-ignore: decorator\n  @inline\n  export const SPIPE: errno = 70;\n  /** No such process. */\n  // @ts-ignore: decorator\n  @inline\n  export const SRCH: errno = 71;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const STALE: errno = 72;\n  /** Connection timed out. */\n  // @ts-ignore: decorator\n  @inline\n  export const TIMEDOUT: errno = 73;\n  /** Text file busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const TXTBSY: errno = 74;\n  /** Cross-device link. */\n  // @ts-ignore: decorator\n  @inline\n  export const XDEV: errno = 75;\n  /** Extension: Capabilities insufficient. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCAPABLE: errno = 76;\n}\nexport type errno = u16;\n\n/** An event that occurred. */\n@unmanaged export abstract class event {\n  /** User-provided value that got attached to `subscription#userdata`. */\n  userdata: userdata;\n  /** If non-zero, an error that occurred while processing the subscription request. */\n  error: errno;\n  /** The type of the event that occurred. */\n  type: eventtype;\n\n  private __padding0: u16;\n}\n\n/** An event that occurred when type is `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\n@unmanaged export class event_fd_readwrite extends event {\n  /* The number of bytes available for reading or writing. */\n  nbytes: filesize;\n  /* The state of the file descriptor. */\n  flags: eventrwflags;\n\n  private __padding1: u32;\n}\n\n/** The state of the file descriptor subscribed to with `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\nexport namespace eventrwflags {\n  /** The peer of this socket has closed or disconnected. */\n  // @ts-ignore: decorator\n  @inline\n  export const HANGUP: eventrwflags = 1;\n}\nexport type eventrwflags = u16;\n\n/** Type of a subscription to an event or its occurrence. */\nexport namespace eventtype {\n  /** The time value of clock has reached the timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const CLOCK: eventtype = 0;\n  /** File descriptor has data available for reading. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: eventtype = 1;\n  /** File descriptor has capacity available for writing */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: eventtype = 2;\n}\nexport type eventtype = u8;\n\n/** Exit code generated by a process when exiting. */\nexport type exitcode = u32;\n\n/** A file descriptor number. */\nexport type fd = u32;\n\n/** File descriptor flags. */\nexport namespace fdflags {\n  /** Append mode: Data written to the file is always appended to the file's end. */\n  // @ts-ignore: decorator\n  @inline\n  export const APPEND: fdflags = 1;\n  /** Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized. */\n  // @ts-ignore: decorator\n  @inline\n  export const DSYNC: fdflags = 2;\n  /** Non-blocking mode. */\n  // @ts-ignore: decorator\n  @inline\n  export const NONBLOCK: fdflags = 4;\n  /** Synchronized read I/O operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RSYNC: fdflags = 8;\n  /** Write according to synchronized I/O file integrity completion. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYNC: fdflags = 16;\n}\nexport type fdflags = u16;\n\n/** File descriptor attributes. */\n@unmanaged export class fdstat {\n  /** File type. */\n  filetype: filetype;\n  /** File descriptor flags. */\n  flags: fdflags;\n  /** Rights that apply to this file descriptor. */\n  rights_base: rights;\n  /** Maximum set of rights that may be installed on new file descriptors that are created through this file descriptor, e.g., through `path_open`. */\n  rights_inheriting: rights;\n}\n\n/** Relative offset within a file. */\nexport type filedelta = i64;\n\n/** Non-negative file size or length of a region within a file. */\nexport type filesize = u64;\n\n/** File attributes. */\n@unmanaged export class filestat {\n  /** Device ID of device containing the file. */\n  dev: device;\n  /** File serial number. */\n  ino: inode;\n  /** File type. */\n  filetype: filetype;\n  /** Number of hard links to the file. */\n  nlink: linkcount;\n  /** For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link. */\n  size: filesize;\n  /** Last data access timestamp. */\n  atim: timestamp;\n  /** Last data modification timestamp. */\n  mtim: timestamp;\n  /** Last file status change timestamp. */\n  ctim: timestamp;\n}\n\n/** The type of a file descriptor or file. */\nexport namespace filetype {\n  /** The type of the file descriptor or file is unknown or is different from any of the other types specified. */\n  // @ts-ignore: decorator\n  @inline\n  export const UNKNOWN: filetype = 0;\n  /** The file descriptor or file refers to a block device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const BLOCK_DEVICE: filetype = 1;\n  /** The file descriptor or file refers to a character device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHARACTER_DEVICE: filetype = 2;\n  /** The file descriptor or file refers to a directory inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: filetype = 3;\n  /** The file descriptor or file refers to a regular file inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const REGULAR_FILE: filetype = 4;\n  /** The file descriptor or file refers to a datagram socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_DGRAM: filetype = 5;\n  /** The file descriptor or file refers to a byte-stream socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_STREAM: filetype = 6;\n  /** The file refers to a symbolic link inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMBOLIC_LINK: filetype = 7;\n}\nexport type filetype = u8;\n\n/** Which file time attributes to adjust. */\nexport namespace fstflags {\n  /** Adjust the last data access timestamp to the value stored in `filestat#st_atim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM: fstflags = 1;\n  /** Adjust the last data access timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM_NOW: fstflags = 2;\n  /** Adjust the last data modification timestamp to the value stored in `filestat#st_mtim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM: fstflags = 4;\n  /** Adjust the last data modification timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM_NOW: fstflags = 8;\n}\nexport type fstflags = u16;\n\n/** File serial number that is unique within its file system. */\nexport type inode = u64;\n\n/** A region of memory for scatter/gather reads. */\n@unmanaged export class iovec {\n  /** The address of the buffer to be filled. */\n  buf: usize;\n  /** The length of the buffer to be filled. */\n  buf_len: usize;\n}\n\n/** Number of hard links to an inode. */\nexport type linkcount = u64;\n\n/** Flags determining the method of how paths are resolved. */\nexport namespace lookupflags {\n  /** As long as the resolved path corresponds to a symbolic link, it is expanded. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMLINK_FOLLOW: lookupflags = 1;\n}\nexport type lookupflags = u32;\n\n/** Open flags. */\nexport namespace oflags {\n  /** Create file if it does not exist. */\n  // @ts-ignore: decorator\n  @inline\n  export const CREAT: oflags = 1;\n  /** Fail if not a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: oflags = 2;\n  /** Fail if file already exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXCL: oflags = 4;\n  /** Truncate file to size 0. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRUNC: oflags = 8;\n}\nexport type oflags = u16;\n\n/** Identifiers for preopened capabilities. */\nexport namespace preopentype {\n  /** A pre-opened directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIR: preopentype = 0;\n}\nexport type preopentype = u8;\n\n/* Information about a pre-opened capability. */\nexport abstract class prestat {\n  /* The type of the pre-opened capability. */\n  type: preopentype;\n}\n\n/** The contents of a $prestat when type is `preopentype.DIR`. */\nexport class prestat_dir extends prestat {\n  /** The length of the directory name for use with `fd_prestat_dir_name`. */\n  name_len: usize;\n}\n\n/** Flags provided to `sock_recv`. */\nexport namespace riflags {\n  /** Returns the message without removing it from the socket's receive queue. */\n  // @ts-ignore: decorator\n  @inline\n  export const PEEK: riflags = 1;\n  /** On byte-stream sockets, block until the full amount of data can be returned. */\n  // @ts-ignore: decorator\n  @inline\n  export const WAITALL: riflags = 2;\n}\nexport type riflags = u16;\n\n/** File descriptor rights, determining which actions may be performed. */\nexport namespace rights {\n  /** The right to invoke `fd_datasync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_DATASYNC: rights = 1;\n  /** The right to invoke `fd_read` and `sock_recv`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: rights = 2;\n  /** The right to invoke `fd_seek`. This flag implies `rights.FD_TELL`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SEEK: rights = 4;\n  /** The right to invoke `fd_fdstat_set_flags`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FDSTAT_SET_FLAGS: rights = 8;\n  /** The right to invoke `fd_sync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SYNC: rights = 16;\n  /** The right to invoke `fd_seek` in such a way that the file offset remains unaltered (i.e., `whence.CUR` with offset zero), or to invoke `fd_tell`). */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_TELL: rights = 32;\n  /** The right to invoke `fd_write` and `sock_send`. If `rights.FD_SEEK` is set, includes the right to invoke `fd_pwrite`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: rights = 64;\n  /** The right to invoke `fd_advise`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ADVISE: rights = 128;\n  /** The right to invoke `fd_allocate`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ALLOCATE: rights = 256;\n  /** The right to invoke `path_create_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_DIRECTORY: rights = 512;\n  /** If `rights.PATH_OPEN` is set, the right to invoke `path_open` with `oflags.CREAT`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_FILE: rights = 1024;\n  /** The right to invoke `path_link` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_SOURCE: rights = 2048;\n  /** The right to invoke `path_link` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_TARGET: rights = 4096;\n  /** The right to invoke `path_open`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_OPEN: rights = 8192;\n  /** The right to invoke `fd_readdir`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READDIR: rights = 16384;\n  /** The right to invoke `path_readlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_READLINK: rights = 32768;\n  /** The right to invoke `path_rename` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_SOURCE: rights = 65536;\n  /** The right to invoke `path_rename` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_TARGET: rights = 131072;\n  /** The right to invoke `path_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_GET: rights = 262144;\n  /** The right to change a file's size (there is no `path_filestat_set_size`). If `rights.PATH_OPEN` is set, includes the right to invoke `path_open` with `oflags.TRUNC`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_SIZE: rights = 524288;\n  /** The right to invoke `path_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_TIMES: rights = 1048576;\n  /** The right to invoke `fd_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_GET: rights = 2097152;\n  /** The right to invoke `fd_filestat_set_size`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_SIZE: rights = 4194304;\n  /** The right to invoke `fd_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_TIMES: rights = 8388608;\n  /** The right to invoke `path_symlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const RIGHT_PATH_SYMLINK: rights = 16777216;\n  /** The right to invoke `path_remove_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_REMOVE_DIRECTORY: rights = 33554432;\n  /** The right to invoke `path_unlink_file`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_UNLINK_FILE: rights = 67108864;\n  /** If `rights.FD_READ` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_READ`. If `rights.FD_WRITE` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_WRITE`. */\n  // @ts-ignore: decorator\n  @inline\n  export const POLL_FD_READWRITE: rights = 134217728;\n  /** The right to invoke `sock_shutdown`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCK_SHUTDOWN: rights = 268435456;\n}\nexport type rights = u64;\n\n/** Flags returned by `sock_recv`. */\nexport namespace roflags {\n  /** Message data has been truncated. */\n  // @ts-ignore: decorator\n  @inline\n  export const DATA_TRUNCATED: roflags = 1;\n}\nexport type roflags = u16;\n\n/** Which channels on a socket to shut down. */\nexport namespace sdflags {\n  /** Disables further receive operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RD: sdflags = 1;\n  /** Disables further send operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const WR: sdflags = 2;\n}\nexport type sdflags = u8;\n\n/** Flags provided to `sock_send`. */\nexport namespace siflags {\n  // As there are currently no flags defined, it must be set to zero.\n}\nexport type siflags = u16;\n\n/** Signal condition. */\nexport namespace signal {\n  /** Hangup. */\n  // @ts-ignore: decorator\n  @inline\n  export const HUP: signal = 1;\n  /** Terminate interrupt signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const INT: signal = 2;\n  /** Terminal quit signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const QUIT: signal = 3;\n  /** Illegal instruction. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILL: signal = 4;\n  /** Trace/breakpoint trap. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRAP: signal = 5;\n  /** Process abort signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABRT: signal = 6;\n  /** Access to an undefined portion of a memory object. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUS: signal = 7;\n  /** Erroneous arithmetic operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const FPE: signal = 8;\n  /** Kill. */\n  // @ts-ignore: decorator\n  @inline\n  export const KILL: signal = 9;\n  /** User-defined signal 1. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR1: signal = 10;\n  /** Invalid memory reference. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEGV: signal = 11;\n  /** User-defined signal 2. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR2: signal = 12;\n  /** Write on a pipe with no one to read it. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: signal = 13;\n  /** Alarm clock. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALRM: signal = 14;\n  /** Termination signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TERM: signal = 15;\n  /** Child process terminated, stopped, or continued. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHLD: signal = 16;\n  /** Continue executing, if stopped. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONT: signal = 17;\n  /** Stop executing. */\n  // @ts-ignore: decorator\n  @inline\n  export const STOP: signal = 18;\n  /** Terminal stop signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TSTP: signal = 19;\n  /** Background process attempting read. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTIN: signal = 20;\n  /** Background process attempting write. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTOU: signal = 21;\n  /** High bandwidth data is available at a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const URG: signal = 22;\n  /** CPU time limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XCPU: signal = 23;\n  /** File size limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XFSZ: signal = 24;\n  /** Virtual timer expired. */\n  // @ts-ignore: decorator\n  @inline\n  export const VTALRM: signal = 25;\n  // @ts-ignore: decorator\n  @inline\n  export const PROF: signal = 26;\n  // @ts-ignore: decorator\n  @inline\n  export const WINCH: signal = 27;\n  // @ts-ignore: decorator\n  @inline\n  export const POLL: signal = 28;\n  // @ts-ignore: decorator\n  @inline\n  export const PWR: signal = 29;\n  /** Bad system call. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYS: signal = 30;\n}\nexport type signal = u8;\n\n/** Flags determining how to interpret the timestamp provided in `subscription_t::u.clock.timeout. */\nexport namespace subclockflags {\n  /** If set, treat the timestamp provided in `clocksubscription` as an absolute timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABSTIME: subclockflags = 1;\n}\nexport type subclockflags = u16;\n\n/** Subscription to an event. */\n@unmanaged export abstract class subscription {\n  /** User-provided value that is attached to the subscription. */\n  userdata: userdata;\n  /** The type of the event to which to subscribe. */\n  type: eventtype;\n\n  private __padding0: u32;\n}\n\n/* Subscription to an event of type `eventtype.CLOCK`.**/\n@unmanaged export class subscription_clock extends subscription {\n  /** The clock against which to compare the timestamp. */\n  clock_id: clockid;\n  /** The absolute or relative timestamp. */\n  timeout: timestamp;\n  /** The amount of time that the implementation may wait additionally to coalesce with other events. */\n  precision: timestamp;\n  /** Flags specifying whether the timeout is absolute or relative. */\n  flags: subclockflags;\n\n  private __padding1: u32;\n}\n\n/* Subscription to an event of type `eventtype.FD_READ` or `eventtype.FD_WRITE`.**/\n@unmanaged export class subscription_fd_readwrite extends subscription {\n  /** The file descriptor on which to wait for it to become ready for reading or writing. */\n  file_descriptor: fd;\n}\n\n/** Timestamp in nanoseconds. */\nexport type timestamp = u64;\n\n/** User-provided value that may be attached to objects that is retained when extracted from the implementation. */\nexport type userdata = u64;\n\n/** The position relative to which to set the offset of the file descriptor. */\nexport namespace whence {\n  /** Seek relative to start-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET: whence = 0;\n  /** Seek relative to current position. */\n  // @ts-ignore: decorator\n  @inline\n  export const CUR: whence = 1;\n  /** Seek relative to end-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const END: whence = 2;\n}\n\nexport type whence = u8;\n","import {\n  advice,\n  args_get,\n  args_sizes_get,\n  clock_res_get,\n  clock_time_get,\n  clockid,\n  subscription_clock,\n  dircookie,\n  environ_get,\n  environ_sizes_get,\n  errno,\n  event,\n  eventtype,\n  fd_advise,\n  fd_allocate,\n  fd_close,\n  fd_datasync,\n  fd_fdstat_get,\n  fd_fdstat_set_flags,\n  fd_filestat_get,\n  fd_filestat_set_size,\n  fd_filestat_set_times,\n  fd_prestat_dir_name,\n  fd_read,\n  fd_readdir,\n  fd_seek,\n  fd_sync,\n  fd_tell,\n  fd_write,\n  fd,\n  fdflags,\n  fdstat,\n  whence,\n  filesize,\n  filestat,\n  filetype,\n  fstflags,\n  lookupflags,\n  oflags,\n  path_create_directory,\n  path_filestat_get,\n  path_link,\n  path_open,\n  path_rename,\n  path_remove_directory,\n  path_symlink,\n  path_unlink_file,\n  poll_oneoff,\n  proc_exit,\n  random_get,\n  rights,\n} from \"bindings/wasi\";\n\n@lazy const mem64:  u64[] = [0];\n@lazy const mem128: u64[] = [0, 0];\n@lazy const mem256: u64[] = [0, 0, 0, 0];\n\n/**\n * A WASI error\n */\nexport class WASIError extends Error {\n  constructor(message: string = \"\") {\n    super(message);\n    this.name = \"WASIError\";\n  }\n}\n\n/**\n * Portable information about a file\n */\nexport class FileStat {\n  file_type: filetype;\n  file_size: filesize;\n  access_time: f64;\n  modification_time: f64;\n  creation_time: f64;\n\n  constructor(st_buf: usize) {\n    this.file_type = load<u8>(st_buf, 16);\n    this.file_size = load<u64>(st_buf, 24);\n    this.access_time = (load<u64>(st_buf, 32) as f64) / 1e9;\n    this.modification_time = (load<u64>(st_buf, 40) as f64) / 1e9;\n    this.creation_time = (load<u64>(st_buf, 48) as f64) / 1e9;\n  }\n}\n\n/**\n * A descriptor, that doesn't necessarily have to represent a file\n */\nexport class Descriptor {\n  /**\n   * An invalid file descriptor, that can represent an error\n   */\n  static Invalid(): Descriptor { return new Descriptor(-1); };\n\n  /**\n   * The standard input\n   */\n  static Stdin(): Descriptor { return new Descriptor(0); };\n\n  /**\n   * The standard output\n   */\n  static Stdout(): Descriptor { return new Descriptor(1); };\n\n  /**\n   * The standard error\n   */\n  static Stderr(): Descriptor { return new Descriptor(2); };\n\n  /**\n   * Build a new descriptor from a raw WASI file descriptor\n   * @param rawfd a raw file descriptor\n   */\n  constructor(readonly rawfd: fd) { }\n\n  /**\n   * Hint at how the data accessible via the descriptor will be used\n   * @offset offset\n   * @len length\n   * @advice `advice.{NORMAL, SEQUENTIAL, RANDOM, WILLNEED, DONTNEED, NOREUSE}`\n   * @returns `true` on success, `false` on error\n   */\n  advise(offset: u64, len: u64, advice: advice): bool {\n    return fd_advise(this.rawfd, offset, len, advice) === errno.SUCCESS;\n  }\n\n  /**\n   * Preallocate data\n   * @param offset where to start preallocating data in the file\n   * @param len bytes to preallocate\n   * @returns `true` on success, `false` on error\n   */\n  allocate(offset: u64, len: u64): bool {\n    return fd_allocate(this.rawfd, offset, len) === errno.SUCCESS;\n  }\n\n  /**\n   * Wait for the data to be written\n   * @returns `true` on success, `false` on error\n   */\n  fdatasync(): bool {\n    return fd_datasync(this.rawfd) === errno.SUCCESS;\n  }\n\n  /**\n   * Wait for the data and metadata to be written\n   * @returns `true` on success, `false` on error\n   */\n  fsync(): bool {\n    return fd_sync(this.rawfd) === errno.SUCCESS;\n  }\n\n  /**\n   * Return the file type\n   */\n  fileType(): filetype {\n    let st_buf = changetype<usize>(new ArrayBuffer(24));\n    if (fd_fdstat_get(this.rawfd, changetype<fdstat>(st_buf)) !== errno.SUCCESS) {\n      throw new WASIError(\"Unable to get the file type\");\n    }\n    let file_type = load<u8>(st_buf);\n\n    return file_type;\n  }\n\n  /**\n   * Set WASI flags for that descriptor\n   * @params flags: one or more of `fdflags.{APPEND, DSYNC, NONBLOCK, RSYNC, SYNC}`\n   * @returns `true` on success, `false` on error\n   */\n  setFlags(flags: fdflags): bool {\n    return fd_fdstat_set_flags(this.rawfd, flags) === errno.SUCCESS;\n  }\n\n  /**\n   * Retrieve information about a descriptor\n   * @returns a `FileStat` object`\n   */\n  stat(): FileStat {\n    let st_buf = changetype<usize>(new ArrayBuffer(56));\n    if (fd_filestat_get(this.rawfd, changetype<filestat>(st_buf)) !== errno.SUCCESS) {\n      throw new WASIError(\"Unable to get the file information\");\n    }\n    return new FileStat(st_buf);\n  }\n\n  /**\n   * Change the size of a file\n   * @param size new size\n   * @returns `true` on success, `false` on error\n   */\n  ftruncate(size: u64 = 0): bool {\n    return fd_filestat_set_size(this.rawfd, size) === errno.SUCCESS;\n  }\n\n  /**\n   * Update the access time\n   * @ts timestamp in seconds\n   * @returns `true` on success, `false` on error\n   */\n  fatime(ts: f64): bool {\n    return (\n      fd_filestat_set_times(this.rawfd, (ts * 1e9) as u64, 0, fstflags.SET_ATIM) ===\n      errno.SUCCESS\n    );\n  }\n\n  /**\n   * Update the modification time\n   * @ts timestamp in seconds\n   * @returns `true` on success, `false` on error\n   */\n  fmtime(ts: f64): bool {\n    return (\n      fd_filestat_set_times(this.rawfd, 0, (ts * 1e9) as u64, fstflags.SET_MTIM) ===\n      errno.SUCCESS\n    );\n  }\n\n  /**\n   * Update both the access and the modification times\n   * @atime timestamp in seconds\n   * @mtime timestamp in seconds\n   * @returns `true` on success, `false` on error\n   */\n  futimes(atime: f64, mtime: f64): bool {\n    return (\n      fd_filestat_set_times(\n        this.rawfd,\n        (atime * 1e9) as u64,\n        (mtime * 1e9) as u64,\n        fstflags.SET_ATIM | fstflags.SET_ATIM\n      ) === errno.SUCCESS\n    );\n  }\n\n  /**\n   * Update the timestamp of the object represented by the descriptor\n   * @returns `true` on success, `false` on error\n   */\n  touch(): bool {\n    return (\n      fd_filestat_set_times(\n        this.rawfd,\n        0,\n        0,\n        fstflags.SET_ATIM_NOW | fstflags.SET_MTIM_NOW\n      ) === errno.SUCCESS\n    );\n  }\n\n  /**\n   * Return the directory associated to that descriptor\n   */\n  dirName(): string {\n    let path_max = 4096 as usize;\n    let path_buf = __alloc(path_max, 0);\n    while (true) {\n      let ret = fd_prestat_dir_name(this.rawfd, path_buf, path_max);\n      if (ret === errno.NAMETOOLONG) {\n        path_max *= 2;\n        path_buf = __realloc(path_buf, path_max);\n        continue;\n      }\n      let path = String.UTF8.decodeUnsafe(path_buf, path_max, true);\n      __free(path_buf);\n      return path;\n    }\n  }\n\n  /**\n   * Close a file descriptor\n   */\n  close(): void {\n    fd_close(this.rawfd);\n  }\n\n  /**\n   * Write data to a file descriptor\n   * @param data data\n   */\n  write(data: u8[]): void {\n    let data_buf_len = data.length;\n    let data_buf_out = changetype<usize>(new ArrayBuffer(data_buf_len));\n    // @ts-ignore: cast\n    let data_buf_in = changetype<ArrayBufferView>(data).dataStart;\n    memory.copy(data_buf_out, data_buf_in, data_buf_len);\n    // @ts-ignore: cast\n    let iov = changetype<ArrayBufferView>(mem128).dataStart;\n    store<u32>(iov, data_buf_out, 0);\n    store<u32>(iov, data_buf_len, sizeof<usize>());\n\n    // @ts-ignore: cast\n    let written_ptr = changetype<ArrayBufferView>(mem64).dataStart;\n    fd_write(this.rawfd, iov, 1, written_ptr);\n  }\n\n  /**\n     * Write a string to a file descriptor, after encoding it to UTF8\n     * @param s string\n     * @param newline `true` to add a newline after the string\n     */\n  writeString(s: string, newline: bool = false): void {\n    if (newline) {\n      this.writeStringLn(s);\n      return;\n    }\n    let s_utf8_buf = String.UTF8.encode(s);\n    let s_utf8_len: usize = s_utf8_buf.byteLength;\n    // @ts-ignore: cast\n    let iov = changetype<ArrayBufferView>(mem128).dataStart;\n    store<u32>(iov, changetype<usize>(s_utf8_buf));\n    store<u32>(iov, s_utf8_len, sizeof<usize>());\n\n    // @ts-ignore: cast\n    let written_ptr = changetype<ArrayBufferView>(mem64).dataStart;\n    fd_write(this.rawfd, iov, 1, written_ptr);\n  }\n\n  /**\n   * Write a string to a file descriptor, after encoding it to UTF8, with a newline\n   * @param s string\n   */\n  writeStringLn(s: string): void {\n    let s_utf8_buf = String.UTF8.encode(s);\n    let s_utf8_len: usize = s_utf8_buf.byteLength;\n    // @ts-ignore: cast\n    let iov = changetype<ArrayBufferView>(mem256).dataStart;\n    store<u32>(iov, changetype<usize>(s_utf8_buf));\n    store<u32>(iov, s_utf8_len, sizeof<usize>());\n    // @ts-ignore: cast\n    let lf = changetype<ArrayBufferView>(mem64).dataStart;\n    store<u8>(lf, 10);\n    store<u32>(iov, lf, sizeof<usize>() * 2);\n    store<u32>(iov,  1, sizeof<usize>() * 3);\n\n    // @ts-ignore: cast\n    let written_ptr = changetype<ArrayBufferView>(mem64).dataStart;\n    fd_write(this.rawfd, iov, 2, written_ptr);\n  }\n\n  /**\n   * Read data from a file descriptor\n   * @param data existing array to push data to\n   * @param chunk_size chunk size (default: 4096)\n   */\n  read(\n    data: u8[] = [],\n    chunk_size: usize = 4096\n  ): u8[] | null {\n    let data_partial_len = chunk_size;\n    let data_partial = changetype<usize>(new ArrayBuffer(data_partial_len));\n    // @ts-ignore: cast\n    let iov = changetype<ArrayBufferView>(mem128).dataStart;\n    store<u32>(iov, data_partial, 0);\n    store<u32>(iov, data_partial_len, sizeof<usize>());\n    // @ts-ignore: cast\n    let read_ptr = changetype<ArrayBufferView>(mem64).dataStart;\n    fd_read(this.rawfd, iov, 1, read_ptr);\n    let read = load<usize>(read_ptr);\n    if (read > 0) {\n      for (let i: usize = 0; i < read; i++) {\n        data.push(load<u8>(data_partial + i));\n      }\n    }\n    return read <= 0 ? null : data;\n  }\n\n  /**\n   * Read from a file descriptor until the end of the stream\n   * @param data existing array to push data to\n   * @param chunk_size chunk size (default: 4096)\n   */\n  readAll(\n    data: u8[] = [],\n    chunk_size: usize = 4096\n  ): Array<u8> | null {\n    let data_partial_len = chunk_size;\n    let data_partial = changetype<usize>(new ArrayBuffer(data_partial_len));\n    // @ts-ignore: cast\n    let iov = changetype<ArrayBufferView>(mem128).dataStart;\n    store<u32>(iov, data_partial, 0);\n    store<u32>(iov, data_partial_len, sizeof<usize>());\n    // @ts-ignore: cast\n    let read_ptr = changetype<ArrayBufferView>(mem64).dataStart;\n    let read: usize = 0;\n    let rawfd = this.rawfd;\n    while (true) {\n      if (fd_read(rawfd, iov, 1, read_ptr) !== errno.SUCCESS) {\n        break;\n      }\n      read = load<usize>(read_ptr);\n      if (read <= 0) {\n        break;\n      }\n      for (let i: usize = 0; i < read; i++) {\n        data.push(load<u8>(data_partial + i));\n      }\n    }\n    if (read < 0) {\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * Read an UTF8 string from a file descriptor, convert it to a native string\n   * @param chunk_size chunk size (default: 4096)\n   */\n  readString(chunk_size: usize = 4096): string | null {\n    let s_utf8 = this.readAll();\n    if (s_utf8 === null) {\n      return null;\n    }\n    // @ts-ignore: cast\n    return String.UTF8.decodeUnsafe(s_utf8.dataStart, s_utf8.length);\n  }\n\n  /**\n   * Seek into a stream\n   * @off offset\n   * @w the position relative to which to set the offset of the file descriptor.\n   */\n  seek(off: u64, w: whence): bool {\n    // @ts-ignore: cast\n    let fodder = changetype<ArrayBufferView>(mem64).dataStart;\n    let res = fd_seek(this.rawfd, off, w, fodder);\n\n    return res === errno.SUCCESS;\n  }\n\n  /**\n   * Return the current offset in the stream\n   * @returns offset\n   */\n  tell(): u64 {\n    // @ts-ignore: cast\n    let buf_off = changetype<ArrayBufferView>(mem64).dataStart;\n    let res = fd_tell(this.rawfd, buf_off);\n    if (res !== errno.SUCCESS) {\n      abort();\n    }\n    return load<u64>(buf_off);\n  }\n}\n\n/**\n * A class to access a filesystem\n */\nexport class FileSystem {\n  /**\n   * Open a path\n   * @path path\n   * @flags r, r+, w, wx, w+ or xw+\n   * @returns a descriptor\n   */\n  static open(path: string, flags: string = \"r\"): Descriptor | null {\n    let dirfd = this.dirfdForPath(path);\n    let fd_lookup_flags = lookupflags.SYMLINK_FOLLOW;\n    let fd_oflags: u16 = 0;\n    let fd_rights: u64 = 0;\n    if (flags == \"r\") {\n      fd_rights =\n        rights.FD_READ | rights.FD_SEEK | rights.FD_TELL | rights.FD_FILESTAT_GET |\n        rights.FD_READDIR;\n    } else if (flags == \"r+\") {\n      fd_rights =\n        rights.FD_WRITE |\n        rights.FD_READ  | rights.FD_SEEK | rights.FD_TELL | rights.FD_FILESTAT_GET |\n        rights.PATH_CREATE_FILE;\n    } else if (flags == \"w\") {\n      fd_oflags = oflags.CREAT | oflags.TRUNC;\n      fd_rights =\n        rights.FD_WRITE | rights.FD_SEEK | rights.FD_TELL | rights.FD_FILESTAT_GET |\n        rights.PATH_CREATE_FILE;\n    } else if (flags == \"wx\") {\n      fd_oflags = oflags.CREAT | oflags.TRUNC | oflags.EXCL;\n      fd_rights =\n        rights.FD_WRITE | rights.FD_SEEK | rights.FD_TELL | rights.FD_FILESTAT_GET |\n        rights.PATH_CREATE_FILE;\n    } else if (flags == \"w+\") {\n      fd_oflags = oflags.CREAT | oflags.TRUNC;\n      fd_rights =\n        rights.FD_WRITE |\n        rights.FD_READ  | rights.FD_SEEK | rights.FD_TELL | rights.FD_FILESTAT_GET |\n        rights.PATH_CREATE_FILE;\n    } else if (flags == \"xw+\") {\n      fd_oflags = oflags.CREAT | oflags.TRUNC | oflags.EXCL;\n      fd_rights =\n        rights.FD_WRITE |\n        rights.FD_READ  | rights.FD_SEEK | rights.FD_TELL | rights.FD_FILESTAT_GET |\n        rights.PATH_CREATE_FILE;\n    } else {\n      return null;\n    }\n    let fd_rights_inherited = fd_rights;\n    let fd_flags: fdflags = 0;\n    let path_utf8_buf = String.UTF8.encode(path);\n    let path_utf8_len: usize = path_utf8_buf.byteLength;\n    let path_utf8 = changetype<usize>(path_utf8_buf);\n    // @ts-ignore: cast\n    let fd_buf = changetype<ArrayBufferView>(mem64).dataStart;\n    let res = path_open(\n      dirfd as fd,\n      fd_lookup_flags,\n      path_utf8, path_utf8_len,\n      fd_oflags,\n      fd_rights,\n      fd_rights_inherited,\n      fd_flags,\n      fd_buf\n    );\n    if (res !== errno.SUCCESS) {\n      return null;\n    }\n    let fd = load<u32>(fd_buf);\n    return new Descriptor(fd);\n  }\n\n  /**\n   * Create a new directory\n   * @path path\n   * @returns `true` on success, `false` on failure\n   */\n  static mkdir(path: string): bool {\n    let dirfd = this.dirfdForPath(path);\n\n    let path_utf8_buf = String.UTF8.encode(path);\n    let path_utf8_len: usize = path_utf8_buf.byteLength;\n    let path_utf8 = changetype<usize>(path_utf8_buf);\n\n    let res = path_create_directory(dirfd, path_utf8, path_utf8_len);\n\n    return res === errno.SUCCESS;\n  }\n\n  /**\n   * Check if a file exists at a given path\n   * @path path\n   * @returns `true` on success, `false` on failure\n   */\n  static exists(path: string): bool {\n    let dirfd = this.dirfdForPath(path);\n    let path_utf8_buf = String.UTF8.encode(path);\n    let path_utf8_len: usize = path_utf8_buf.byteLength;\n    let path_utf8 = changetype<usize>(path_utf8_buf);\n    let fd_lookup_flags = lookupflags.SYMLINK_FOLLOW;\n    let st_buf = changetype<usize>(new ArrayBuffer(56));\n    let res = path_filestat_get(\n      dirfd,\n      fd_lookup_flags,\n      path_utf8, path_utf8_len,\n      changetype<filestat>(st_buf)\n    );\n\n    return res === errno.SUCCESS;\n  }\n\n  /**\n   * Create a hard link\n   * @old_path old path\n   * @new_path new path\n   * @returns `true` on success, `false` on failure\n   */\n  static link(old_path: string, new_path: string): bool {\n    let old_dirfd = this.dirfdForPath(old_path);\n\n    let old_path_utf8_buf = String.UTF8.encode(old_path);\n    let old_path_utf8_len: usize = old_path_utf8_buf.byteLength;\n    let old_path_utf8 = changetype<usize>(old_path_utf8_buf);\n\n    let new_dirfd = this.dirfdForPath(new_path);\n\n    let new_path_utf8_buf = String.UTF8.encode(new_path);\n    let new_path_utf8_len: usize = new_path_utf8_buf.byteLength;\n    let new_path_utf8 = changetype<usize>(new_path_utf8_buf);\n\n    let fd_lookup_flags = lookupflags.SYMLINK_FOLLOW;\n    let res = path_link(\n      old_dirfd,\n      fd_lookup_flags,\n      old_path_utf8, old_path_utf8_len,\n      new_dirfd,\n      new_path_utf8, new_path_utf8_len\n    );\n\n    return res === errno.SUCCESS;\n  }\n\n  /**\n   * Create a symbolic link\n   * @old_path old path\n   * @new_path new path\n   * @returns `true` on success, `false` on failure\n   */\n  static symlink(old_path: string, new_path: string): bool {\n    let old_path_utf8_buf = String.UTF8.encode(old_path);\n    let old_path_utf8_len: usize = old_path_utf8_buf.byteLength;\n    let old_path_utf8 = changetype<usize>(old_path_utf8_buf);\n\n    let new_dirfd = this.dirfdForPath(new_path);\n\n    let new_path_utf8_buf = String.UTF8.encode(new_path);\n    let new_path_utf8_len: usize = new_path_utf8_buf.byteLength;\n    let new_path_utf8 = changetype<usize>(new_path_utf8_buf);\n\n\n    let res = path_symlink(\n      old_path_utf8, old_path_utf8_len,\n      new_dirfd,\n      new_path_utf8, new_path_utf8_len\n    );\n\n    return res === errno.SUCCESS;\n  }\n\n  /**\n   * Unlink a file\n   * @path path\n   * @returns `true` on success, `false` on failure\n   */\n  static unlink(path: string): bool {\n    let dirfd = this.dirfdForPath(path);\n\n    let path_utf8_buf = String.UTF8.encode(path);\n    let path_utf8_len: usize = path_utf8_buf.byteLength;\n    let path_utf8 = changetype<usize>(path_utf8_buf);\n\n    let res = path_unlink_file(dirfd, path_utf8, path_utf8_len);\n\n    return res === errno.SUCCESS;\n  }\n\n  /**\n   * Remove a directory\n   * @path path\n   * @returns `true` on success, `false` on failure\n   */\n  static rmdir(path: string): bool {\n    let dirfd = this.dirfdForPath(path);\n\n    let path_utf8_buf = String.UTF8.encode(path);\n    let path_utf8_len: usize = path_utf8_buf.byteLength;\n    let path_utf8 = changetype<usize>(path_utf8_buf);\n\n    let res = path_remove_directory(dirfd, path_utf8, path_utf8_len);\n\n    return res === errno.SUCCESS;\n  }\n\n  /**\n   * Retrieve information about a file\n   * @path path\n   * @returns a `FileStat` object\n   */\n  static stat(path: string): FileStat {\n    let dirfd = this.dirfdForPath(path);\n\n    let path_utf8_buf = String.UTF8.encode(path);\n    let path_utf8_len: usize = path_utf8_buf.byteLength;\n    let path_utf8 = changetype<usize>(path_utf8_buf);\n\n    let fd_lookup_flags = lookupflags.SYMLINK_FOLLOW;\n    let st_buf = changetype<usize>(new ArrayBuffer(56));\n    if (path_filestat_get(\n      dirfd,\n      fd_lookup_flags,\n      path_utf8, path_utf8_len,\n      changetype<filestat>(st_buf)\n    ) !== errno.SUCCESS) {\n      throw new WASIError(\"Unable to get the file information\");\n    }\n    return new FileStat(st_buf);\n  }\n\n  /**\n   * Retrieve information about a file or a symbolic link\n   * @path path\n   * @returns a `FileStat` object\n   */\n  static lstat(path: string): FileStat {\n    let dirfd = this.dirfdForPath(path);\n\n    let path_utf8_buf = String.UTF8.encode(path);\n    let path_utf8_len: usize = path_utf8_buf.byteLength;\n    let path_utf8 = changetype<usize>(path_utf8_buf);\n\n    let fd_lookup_flags = 0;\n    let st_buf = changetype<usize>(new ArrayBuffer(56));\n    if (path_filestat_get(\n      dirfd,\n      fd_lookup_flags,\n      path_utf8, path_utf8_len,\n      changetype<filestat>(st_buf)\n    ) !== errno.SUCCESS) {\n      throw new WASIError(\"Unable to get the file information\");\n    }\n    return new FileStat(st_buf);\n  }\n\n  /**\n   * Rename a file\n   * @old_path old path\n   * @new_path new path\n   * @returns `true` on success, `false` on failure\n   */\n  static rename(old_path: string, new_path: string): bool {\n    let old_dirfd = this.dirfdForPath(old_path);\n\n    let old_path_utf8_buf = String.UTF8.encode(old_path);\n    let old_path_utf8_len: usize = old_path_utf8_buf.byteLength;\n    let old_path_utf8 = changetype<usize>(old_path_utf8_buf);\n\n    let new_dirfd = this.dirfdForPath(new_path);\n\n    let new_path_utf8_buf = String.UTF8.encode(new_path);\n    let new_path_utf8_len: usize = new_path_utf8_buf.byteLength;\n    let new_path_utf8 = changetype<usize>(new_path_utf8_buf);\n\n    let res = path_rename(\n      old_dirfd,\n      old_path_utf8, old_path_utf8_len,\n      new_dirfd,\n      new_path_utf8, new_path_utf8_len\n    );\n\n    return res === errno.SUCCESS;\n  }\n\n  /**\n   * Get the content of a directory\n   * @param path the directory path\n   * @returns An array of file names\n   */\n  static readdir(path: string): Array<string> | null {\n    let fd = this.open(path, \"r\");\n    if (fd === null) {\n      return null;\n    }\n    let out = new Array<string>();\n    let buf_size = 4096;\n    let buf = __alloc(buf_size, 0);\n    // @ts-ignore: cast\n    let buf_used_p = changetype<ArrayBufferView>(mem64).dataStart;\n    let buf_used = 0;\n    for (; ;) {\n      if (fd_readdir(fd.rawfd, buf, buf_size, 0 as dircookie, buf_used_p) !== errno.SUCCESS) {\n        fd.close();\n      }\n      buf_used = load<u32>(buf_used_p);\n      if (buf_used < buf_size) {\n        break;\n      }\n      buf_size <<= 1;\n      buf = __realloc(buf, buf_size);\n    }\n    let offset = 0;\n    while (offset < buf_used) {\n      offset += 16;\n      let name_len = load<u32>(buf + offset);\n      offset += 8;\n      if (offset + name_len > buf_used) {\n        return null;\n      }\n      let name = String.UTF8.decodeUnsafe(buf + offset, name_len);\n      out.push(name);\n      offset += name_len;\n    }\n    __free(buf);\n    fd.close();\n\n    return out;\n  }\n\n  protected static dirfdForPath(path: string): fd {\n    return 3;\n  }\n}\n\n@global\nexport class Console {\n  /**\n   * Write a string to the console\n   * @param s string\n   * @param newline `false` to avoid inserting a newline after the string\n   */\n  static write(s: string, newline: bool = true): void {\n    Descriptor.Stdout().writeString(s, newline);\n  }\n\n  /**\n   * Read an UTF8 string from the console, convert it to a native string\n   */\n  static readAll(): string | null {\n    return Descriptor.Stdin().readString();\n  }\n\n  /**\n   * Alias for `Console.write()`\n   */\n  static log(s: string): void {\n    this.write(s);\n  }\n\n  /**\n   * Write an error to the console\n   * @param s string\n   * @param newline `false` to avoid inserting a newline after the string\n   */\n  static error(s: string, newline: bool = true): void {\n    Descriptor.Stderr().writeString(s, newline);\n  }\n}\n\nexport class Random {\n  /**\n   * Fill a buffer with random data\n   * @param buffer An array buffer\n   */\n  static randomFill(buffer: ArrayBuffer): void {\n    let len = buffer.byteLength;\n    let ptr = changetype<usize>(buffer);\n    while (len > 0) {\n      let chunk = min(len, 256);\n      if (random_get(ptr, chunk) !== errno.SUCCESS) {\n        abort();\n      }\n      len -= chunk;\n      ptr += chunk;\n    }\n  }\n\n  /**\n   * Return an array of random bytes\n   * @param len length\n   */\n  static randomBytes(len: usize): Uint8Array {\n    let array = new Uint8Array(len);\n    this.randomFill(array.buffer);\n    return array;\n  }\n}\n\nexport class Date {\n  /**\n   * Return the current timestamp, as a number of milliseconds since the epoch\n   */\n  static now(): f64 {\n    // @ts-ignore: cast\n    let time_ptr = changetype<ArrayBufferView>(mem64).dataStart;\n    clock_time_get(clockid.REALTIME, 1000000, time_ptr);\n    let unix_ts = load<u64>(time_ptr);\n\n    return (unix_ts as f64) / 1000000.0;\n  }\n}\n\nexport class Performance {\n  static now(): f64 {\n    // @ts-ignore: cast\n    let time_ptr = changetype<ArrayBufferView>(mem64).dataStart;\n    clock_res_get(clockid.MONOTONIC, time_ptr);\n    let res_ts = load<u64>(time_ptr);\n\n    return res_ts as f64;\n  }\n}\n\nexport class Process {\n  /**\n   * Cleanly terminate the current process\n   * @param status exit code\n   */\n  @inline\n  static exit(status: u32): void {\n    proc_exit(status);\n  }\n}\n\nexport class EnvironEntry {\n  constructor(readonly key: string, readonly value: string) { }\n}\n\nexport class Environ {\n  env: Array<EnvironEntry>;\n\n  constructor() {\n    this.env = [];\n    // @ts-ignore: cast\n    let count_and_size = changetype<ArrayBufferView>(mem128).dataStart;\n\n    let ret = environ_sizes_get(count_and_size, count_and_size + 4);\n    if (ret !== errno.SUCCESS) {\n      abort();\n    }\n    let count = load<usize>(count_and_size, 0);\n    let size  = load<usize>(count_and_size, sizeof<usize>());\n    let env_ptrs = changetype<usize>(\n      new ArrayBuffer((count + 1) * sizeof<usize>())\n    );\n    let buf = changetype<usize>(new ArrayBuffer(size));\n    if (environ_get(env_ptrs, buf) !== errno.SUCCESS) {\n      abort();\n    }\n    for (let i: usize = 0; i < count; i++) {\n      let env_ptr = load<usize>(env_ptrs + i * sizeof<usize>());\n      let env_ptr_split = StringUtils.fromCString(env_ptr).split(\"=\", 2);\n      let key = env_ptr_split[0];\n      let value = env_ptr_split[1];\n      this.env.push(new EnvironEntry(key, value));\n    }\n  }\n\n  /**\n   *  Return all environment variables\n   */\n  @inline\n  all(): Array<EnvironEntry> {\n    return this.env;\n  }\n\n  /**\n   * Return the value for an environment variable\n   * @param key environment variable name\n   */\n  get(key: string): string | null {\n    let env = this.env;\n    for (let i = 0, j = env.length; i < j; i++) {\n      let pair = env[i];\n      if (pair.key == key) {\n        return pair.value;\n      }\n    }\n    return null;\n  }\n}\n\nexport class CommandLine {\n  args: string[];\n\n  constructor() {\n    this.args = [];\n    // @ts-ignore: cast\n    let count_and_size = changetype<ArrayBufferView>(mem128).dataStart;\n    let ret = args_sizes_get(count_and_size, count_and_size + 4);\n    if (ret !== errno.SUCCESS) {\n      abort();\n    }\n    let count = load<usize>(count_and_size, 0);\n    let size  = load<usize>(count_and_size, sizeof<usize>());\n    let env_ptrs = changetype<usize>(\n      new ArrayBuffer((count + 1) * sizeof<usize>())\n    );\n    let buf = changetype<usize>(new ArrayBuffer(size));\n    if (args_get(env_ptrs, buf) !== errno.SUCCESS) {\n      abort();\n    }\n    for (let i: usize = 0; i < count; i++) {\n      let env_ptr = load<usize>(env_ptrs + i * sizeof<usize>());\n      let arg = StringUtils.fromCString(env_ptr);\n      this.args.push(arg);\n    }\n  }\n\n  /**\n   * Return all the command-line arguments\n   */\n  @inline\n  all(): Array<string> {\n    return this.args;\n  }\n\n  /**\n   * Return the i-th command-ine argument\n   * @param i index\n   */\n  get(i: usize): string | null {\n    let args = this.args;\n    let args_len: usize = args[0].length;\n    if (i < args_len) {\n      return unchecked(args[i]);\n    }\n    return null;\n  }\n}\n\nexport class Time {\n  static NANOSECOND: i32 = 1;\n  static MILLISECOND: i32 = Time.NANOSECOND * 1000000;\n  static SECOND: i32 = Time.MILLISECOND * 1000;\n\n  static sleep(nanoseconds: i32): void {\n    // Create our subscription to the clock\n    let clockSub = new subscription_clock();\n    clockSub.userdata = 0;\n    clockSub.clock_id = clockid.REALTIME;\n    clockSub.timeout = nanoseconds;\n    clockSub.precision = 10000;\n    clockSub.type = eventtype.CLOCK;\n    clockSub.flags = 0;\n    // We want this to be relative, no flags / subclockflag\n\n    // Create our output event\n    let clockEvent = new event();\n\n    // Create a buffer for our number of sleep events\n    // To inspect how many events happened, one would then do load<i32>(neventsBuffer)\n    // @ts-ignore\n    let neventsBuffer = changetype<ArrayBufferView>(mem64).dataStart;\n\n    // Poll the subscription\n    poll_oneoff(\n      changetype<usize>(clockSub), // Pointer to the clock subscription\n      changetype<usize>(clockEvent), // Pointer to the clock event\n      1, // Number of events to wait for\n      neventsBuffer // Buffer where events should be stored.\n    );\n  }\n}\n\nclass StringUtils {\n  /**\n   * Returns a native string from a zero-terminated C string\n   * @param cstring\n   * @returns native string\n   */\n  @inline\n  static fromCString(cstring: usize): string {\n    return String.UTF8.decodeUnsafe(cstring, i32.MAX_VALUE, true);\n  }\n}\n\n@global\nexport function wasi_abort(\n  message: string = \"\",\n  fileName: string = \"\",\n  lineNumber: u32 = 0,\n  columnNumber: u32 = 0\n): void {\n  Console.error(\n    fileName + \":\" + lineNumber.toString() + \":\" + columnNumber.toString() + \": error: \" + message\n  );\n  proc_exit(255);\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\nimport { ArrayBufferView } from \"../arraybuffer\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline\nconst POWERS10: u32[] = [\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n];\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline\nconst DIGITS: u32[] = [\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n];\n\n// @ts-ignore: decorator\n@lazy @inline\nconst EXP_POWERS: i16[] = [\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n];\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline\nconst FRC_POWERS: u64[] = [\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n];\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return select<u32>(1, 2, value < 10);\n    } else {\n      let m = select<u32>(4, 5, value < 10000);\n      return select<u32>(3, m, value < 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return select<u32>(6, 7, value < 1000000);\n    } else {\n      let m = select<u32>(9, 10, value < 1000000000);\n      return select<u32>(8, m, value < 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      let m = select<u32>(11, 12, value < 100000000000);\n      return select<u32>(10, m, value < 10000000000);\n    } else {\n      let m = select<u32>(14, 15, value < 100000000000000);\n      return select<u32>(13, m, value < 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return select<u32>(16, 17, value < 10000000000000000);\n    } else {\n      let m = select<u32>(19, 20, value < 10000000000000000000);\n      return select<u32>(18, m, value < 1000000000000000000);\n    }\n  }\n}\n\nfunction utoa32_lut(buffer: usize, num: u32, offset: usize): void {\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(lut + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(lut + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(lut + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(lut + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_lut(buffer: usize, num: u64, offset: usize): void {\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(lut + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(lut + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(lut + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(lut + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset -= 1;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_core(buffer: usize, num: u32, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa32_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa64_core(buffer: usize, num: u64, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa64_lut(buffer, num, offset);\n  }\n}\n\nexport function utoa32(value: u32): String {\n  if (!value) return \"0\";\n\n  var decimals = decimalCount32(value);\n  var out = __alloc(decimals << 1, idof<String>());\n\n  utoa32_core(out, value, decimals);\n  return changetype<String>(out); // retains\n}\n\nexport function itoa32(value: i32): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var decimals = decimalCount32(value) + u32(sign);\n  var out = __alloc(decimals << 1, idof<String>());\n\n  utoa32_core(out, value, decimals);\n  if (sign) store<u16>(out, CharCode.MINUS);\n  return changetype<String>(out); // retains\n}\n\nexport function utoa64(value: u64): String {\n  if (!value) return \"0\";\n\n  var out: usize;\n  if (value <= u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_core(out, val32, decimals);\n  } else {\n    let decimals = decimalCount64(value);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_core(out, value, decimals);\n  }\n  return changetype<String>(out); // retains\n}\n\nexport function itoa64(value: i64): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var out: usize;\n  if (<u64>value <= <u64>u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32) + u32(sign);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_core(out, val32, decimals);\n  } else {\n    let decimals = decimalCount64(value) + u32(sign);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_core(out, value, decimals);\n  }\n  if (sign) store<u16>(out, CharCode.MINUS);\n\n  return changetype<String>(out); // retains\n}\n\nexport function itoa<T extends number>(value: T): String {\n  if (!isInteger<T>()) ERROR(\"integer type expected\");\n  if (isSigned<T>()) {\n    if (sizeof<T>() <= 4) {\n      return itoa32(<i32>value);\n    } else {\n      return itoa64(<i64>value);\n    }\n  } else {\n    if (sizeof<T>() <= 4) {\n      return utoa32(<u32>value);\n    } else {\n      return utoa64(<u64>value);\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy\nvar _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n      k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = unchecked(FRC_POWERS[index]);\n  _exp_pow = unchecked(<i32>EXP_POWERS[index]);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = <i32>((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n      exp = select<i32>(exp, 1, exp != 0) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp,      exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n  var wp_w_exp = mp_exp;\n\n  var p1 = <u32>(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  var lut = changetype<ArrayBufferView>(POWERS10).dataStart;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(lut + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (1) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(lut + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n\n  return len;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nexport function dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n      len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite<f64>(value)) {\n    if (isNaN<f64>(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var buffer = __alloc(MAX_DOUBLE_LENGTH << 1, idof<String>());\n  var length = dtoa_core(buffer, value);\n  if (length == MAX_DOUBLE_LENGTH) return changetype<String>(buffer);\n  var result = changetype<String>(buffer).substring(0, length);\n  __free(buffer);\n  return result;\n}\n\nexport function itoa_stream<T extends number>(buffer: usize, offset: usize, value: T): u32 {\n  buffer += (offset << 1);\n  if (!value) {\n    store<u16>(buffer, CharCode._0);\n    return 1;\n  }\n  var decimals: u32 = 0;\n  if (isSigned<T>()) {\n    let sign = i32(value < 0);\n    if (sign) value = changetype<T>(-value);\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value) + <u32>sign;\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32) + <u32>sign;\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value) + <u32>sign;\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n    if (sign) store<u16>(buffer, CharCode.MINUS);\n  } else {\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value);\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32);\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value);\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_stream(buffer: usize, offset: usize, value: f64): u32 {\n  buffer += (offset << 1);\n  if (value == 0.0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite<f64>(value)) {\n    if (isNaN<f64>(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = i32(value < 0);\n      let len  = 8 + sign;\n      memory.copy(buffer, changetype<usize>(select<String>(\"-Infinity\", \"Infinity\", sign)), len << 1);\n      return len;\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","import { itoa, dtoa, itoa_stream, dtoa_stream, MAX_DOUBLE_LENGTH } from \"./number\";\nimport { ipow32 } from \"../math\";\n\n// @ts-ignore\n@lazy const lowerTable127: u8[] = [\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n];\n\n// @ts-ignore\n@lazy const upperTable127: u8[] = [\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n];\n\n// @ts-ignore\n@lazy const lowerTable127Ptr = lowerTable127.dataStart as usize;\n// @ts-ignore\n@lazy const upperTable127Ptr = upperTable127.dataStart as usize;\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy const Powers10: f64[] = [\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n];\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\nexport function isSpace(c: i32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    // @ts-ignore: cast\n    return ((c | 0x80) == 0xA0) | (u32(c - 0x09) <= 0x0D - 0x09);\n  }\n  if (u32(c - 0x2000) <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len = str.length;\n  if (!len) {\n    // @ts-ignore: cast\n    if (isFloat<T>()) return <T>NaN;\n    // @ts-ignore: cast\n    return <T>0;\n  }\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <u32>load<u16>(ptr);\n\n  // determine sign\n  // @ts-ignore: cast\n  var sign: T = 1;\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (code == CharCode.MINUS) {\n    if (!--len) {\n      // @ts-ignore: cast\n      if (isFloat<T>()) return <T>NaN;\n      // @ts-ignore: cast\n      return <T>0;\n    }\n    code = <u32>load<u16>(ptr += 2);\n    // @ts-ignore: type\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) {\n      // @ts-ignore: cast\n      if (isFloat<T>()) return <T>NaN;\n      // @ts-ignore: cast\n      return <T>0;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr + 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    // @ts-ignore: cast\n    if (isFloat<T>()) return <T>NaN;\n    // @ts-ignore: cast\n    return <T>0;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    } else break;\n    if (code >= <u32>radix) break;\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  var len = str.length;\n  if (!len) return NaN;\n\n  var ptr  = changetype<usize>(str);\n  var code = <u32>load<u16>(ptr);\n\n  var sign = 1.;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return copysign<f64>(Infinity, sign);\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  var savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0;\n  const capacity = 19; // int(64 * 0.3010)\n  var pointed = false;\n  var consumed = 0;\n  var position = 0;\n  var x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  var sepLen = separator.length;\n  var valueLen = 5; // max possible length of element len(\"false\")\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  // @ts-ignore: type\n  if (!lastIndex) return changetype<string>(itoa<T>(load<T>(dataStart))); // retains\n\n  var sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    ); // retains\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  var sepLen = separator.length;\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    offset += dtoa_stream(changetype<usize>(result), offset,\n      // @ts-ignore: type\n      value\n    );\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  offset += dtoa_stream(changetype<usize>(result), offset,\n    // @ts-ignore: type\n    value\n  );\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  var estLen = 0;\n  var value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    // @ts-ignore: type\n    if (value !== null) estLen += value.length;\n  }\n  var offset = 0;\n  var sepLen = separator.length;\n  var result = __alloc((estLen + sepLen * lastIndex) << 1, idof<string>());\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (value !== null) {\n      let valueLen = value.length;\n      memory.copy(\n        result + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        result + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (value !== null) {\n    memory.copy(\n      result + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return changetype<string>(result); // retains\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  var value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value !== null ? value.toString() : \"\";\n  }\n  var result = \"\";\n  var sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value !== null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value !== null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  var significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  var shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  var b = <u64>ipow32(5, -exp);\n  var q = significand / b;\n  var r = significand % b;\n  var s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  var shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  var sign = 1, magnitude = 0;\n  var code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy\nvar __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  var low  = (a & 0xFFFFFFFF) * b;\n  var high = (a >> 32) * b + (low >> 32);\n  var overflow = <u32>(high >> 32);\n  var space = clz(overflow);\n  var revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  // @ts-ignore: cast\n  return load<f64>(Powers10.dataStart as usize + (n << alignof<f64>()));\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c & ~0x7F);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: i32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(lowerTable127Ptr + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: i32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(upperTable127Ptr + c);\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, toLower8, toUpper8 } from \"./util/string\";\nimport { specialsUpper, casemap, bsearch } from \"./util/casemap\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\nimport { idof } from \"./builtins\";\n\n@sealed export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = BLOCK_MAXSIZE >>> alignof<u16>();\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    var hasSur = surr > 0;\n    var out = __alloc(2 << i32(hasSur), idof<String>());\n    store<u16>(out, <u16>unit);\n    if (hasSur) store<u16>(out, <u16>surr, 2);\n    return changetype<String>(out); // retains\n  }\n\n  static fromCodePoint(code: i32): String {\n    assert(<u32>code <= 0x10FFFF);\n    var hasSur = code > 0xFFFF;\n    var out = __alloc(2 << i32(hasSur), idof<String>());\n    if (!hasSur) {\n      store<u16>(out, <u16>code);\n    } else {\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = (code >>> 10) | 0xD800;\n      store<u32>(out, lo | (hi << 16));\n    }\n    return changetype<String>(out); // retains\n  }\n\n  get length(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize >> 1;\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    var out = __alloc(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    var len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    var second = <i32>load<u16>(changetype<usize>(this) + ((<usize>pos + 1) << 1));\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return select<String>(left, changetype<String>(\"null\"), left !== null).concat(right);\n  }\n\n  concat(other: String): String {\n    if (other === null) other = changetype<String>(\"null\");\n    var thisSize: isize = this.length << 1;\n    var otherSize: isize = other.length << 1;\n    var outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    var out = changetype<String>(__alloc(outSize, idof<String>())); // retains\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    if (search === null) return false;\n    end = min(max(end, 0), this.length);\n    var searchLength = <isize>search.length;\n    var searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return str === null || !str.length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String | null, right: String | null): bool {\n    if (left === right || left === null || right === null) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return false;\n    var rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) > 0;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n    var rightLength = right.length;\n    if (!rightLength) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) < 0;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    var len = <isize>this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    var len = this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (other === this) return 0; // compare pointers\n    var len: isize = this.length;\n    var otherLen: isize = other.length;\n    if (otherLen != len) return select(1, -1, len > otherLen);\n    if (!otherLen) return 0; // \"\" == \"\"\n    // @ts-ignore: string <-> String\n    return compareImpl(this, 0, other, 0, otherLen);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    if (search === null) search = changetype<String>(\"null\");\n    var len = <isize>this.length;\n    var searchStart = min(max(<isize>start, 0), len);\n    var searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    var intStart: isize = start;\n    var end: isize = length;\n    var len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    var size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + (intStart << 1), size);\n    return changetype<String>(out); // retains\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len: isize = this.length;\n    var finalStart = min<isize>(max(start, 0), len);\n    var finalEnd = min<isize>(max(end, 0), len);\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\n    var size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + fromPos, size);\n    return changetype<String>(out); // retains\n  }\n\n  trim(): String {\n    var len = this.length;\n    var size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    var size = <usize>this.length << 1;\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  trimEnd(): String {\n    var originalSize = <usize>this.length << 1;\n    var size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this), size);\n    return changetype<String>(out); // retains\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var prependSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(out, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out, changetype<usize>(pad), prependSize);\n    }\n    memory.copy(out + prependSize, changetype<usize>(this), thisSize);\n    return changetype<String>(out); //  retains\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var appendSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    memory.copy(out, changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(out + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return changetype<String>(out); // retains\n  }\n\n  repeat(count: i32 = 0): String {\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    var out = __alloc((length * count) << 1, idof<String>());\n    memory.repeat(out, changetype<usize>(this), <usize>length << 1, count);\n    return changetype<String>(out); // retains\n  }\n\n  replace(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = __alloc(olen << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this), index << 1);\n        memory.copy(\n          out + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          out + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return changetype<String>(out);\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var rlen: usize = replacement.length;\n    if (!slen) {\n      if (!rlen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = __alloc((len + (len + 1) * rlen) << 1, idof<String>());\n      memory.copy(out, changetype<usize>(replacement), rlen << 1);\n      let offset = rlen;\n      for (let i: usize = 0; i < len; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        offset += rlen;\n      }\n      return changetype<String>(out);\n    }\n    var prev: isize = 0, next: isize = 0;\n    if (slen == rlen) {\n      // Fast path when search and replacement have same length\n      let size = len << 1;\n      let out = __alloc(size, idof<String>());\n      memory.copy(out, changetype<usize>(this), size);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(out + (next << 1), changetype<usize>(replacement), rlen << 1);\n        prev = next + slen;\n      }\n      return changetype<String>(out);\n    }\n    var out: usize = 0, offset: usize = 0, resLen = len;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = __alloc(len << 1, idof<String>());\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let chunk = next - prev;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(replacement),\n        rlen << 1\n      );\n      offset += rlen;\n      prev = next + slen;\n    }\n    if (offset) {\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let rest = len - prev;\n      if (rest) {\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (resLen > rest) out = __realloc(out, rest << 1);\n      return changetype<String>(out);\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = __alloc(len << 1, idof<String>());\n    memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return changetype<String>(out); // retains\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    if (separator === null) return [this];\n    var length: isize = this.length;\n    var sepLen: isize = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>()));  // retains\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<Array<String>>(__allocArray(length, alignof<String>(), idof<Array<String>>())); // retains\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = __alloc(2, idof<String>());\n        store<u16>(charStr, load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), charStr); // result[i] = charStr\n        if (isManaged<String>()) __retain(charStr);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<Array<String>>(__allocArray(1, alignof<String>(), idof<Array<String>>())); // retains\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    var result = changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    var end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(separator, start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = __alloc(<usize>len << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(changetype<String>(out));\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = __alloc(<usize>len << 1, idof<String>());\n      memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(changetype<String>(out)); // retains\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = __alloc(len * 2 * 2, idof<String>());\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(codes + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(codes + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(codes + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(codes + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(codes + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(codes + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    codes = __realloc(codes, j << 1);\n    return changetype<String>(codes); // retains\n  }\n\n  toUpperCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = __alloc(len * 3 * 2, idof<String>());\n    // @ts-ignore: cast\n    var specialsUpperPtr = specialsUpper.dataStart as usize;\n    var specialsUpperLen = specialsUpper.length;\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(codes + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(codes + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(codes + (j << 1), c - 26);\n        } else {\n          let index = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsUpperPtr, specialsUpperLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsUpperPtr + (index << 1), 2);\n            let cc = load<u16>(specialsUpperPtr + (index << 1), 6);\n            store<u32>(codes + (j << 1), ab, 0);\n            store<u16>(codes + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(codes + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(codes + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    codes = __realloc(codes, j << 1);\n    return changetype<String>(codes); // retains\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      var strOff = changetype<usize>(str);\n      var strEnd = strOff + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false): ArrayBuffer {\n      var strOff = changetype<usize>(str);\n      var strEnd = changetype<usize>(str) + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var bufLen = <usize>UTF8.byteLength(str, nullTerminated);\n      var buf = __alloc(bufLen, idof<ArrayBuffer>());\n      var bufEnd = buf + bufLen - usize(nullTerminated);\n      var bufOff = buf;\n      while (bufOff < bufEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            let c2 = <u32>load<u16>(strOff, 2);\n            if ((c2 & 0xFC00) == 0xDC00) {\n              c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n              let b0 = c1 >> 18 | 240;\n              let b1 = c1 >> 12 & 63 | 128;\n              let b2 = c1 >> 6  & 63 | 128;\n              let b3 = c1       & 63 | 128;\n              store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n              bufOff += 4; strOff += 4;\n              continue;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        strOff += 2;\n      }\n      assert(strOff <= strEnd);\n      if (nullTerminated) {\n        store<u8>(bufOff, 0);\n      }\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      var bufOff = buf;\n      var bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      var str = __alloc(len << 1, idof<String>()); // max is one u16 char per u8 byte\n      var strOff = str;\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__realloc(str, strOff - str)); // retains\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      var size = UTF16.byteLength(str);\n      var buf = __alloc(size, idof<ArrayBuffer>());\n      memory.copy(buf, changetype<usize>(str), <usize>size);\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      var str = __alloc(len &= ~1, idof<String>());\n      memory.copy(str, buf, len);\n      return changetype<String>(str); // retains\n    }\n  }\n}\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src + n <= dest || dest + n <= src) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    store<u8>(dest, c);\n    store<u8>(dest + n - 1, c);\n    if (n <= 2) return;\n\n    store<u8>(dest + 1, c);\n    store<u8>(dest + 2, c);\n    store<u8>(dest + n - 2, c);\n    store<u8>(dest + n - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest + 3, c);\n    store<u8>(dest + n - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    store<u32>(dest, c32);\n    store<u32>(dest + n - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest + 4, c32);\n    store<u32>(dest + 8, c32);\n    store<u32>(dest + n - 12, c32);\n    store<u32>(dest + n - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest + 12, c32);\n    store<u32>(dest + 16, c32);\n    store<u32>(dest + 20, c32);\n    store<u32>(dest + 24, c32);\n    store<u32>(dest + n - 28, c32);\n    store<u32>(dest + n - 24, c32);\n    store<u32>(dest + n - 20, c32);\n    store<u32>(dest + n - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest + 8, c64);\n      store<u64>(dest + 16, c64);\n      store<u64>(dest + 24, c64);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","import { itoa, dtoa } from \"./util/number\";\nimport { strtol } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0;\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@sealed @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool): String {\n    // TODO: radix?\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@sealed @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<i64>(value, radix);\n  }\n\n  static parseFloat(value: string): f32 {\n    return <f32>parseFloat(value);\n  }\n\n  toString(this: f32): String {\n    // TODO: radix\n    return dtoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return <f64>strtol<i64>(value, radix);\n  }\n\n  static parseFloat(value: string): f64 {\n    return parseFloat(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    // TODO: radix\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_MAXSIZE, BLOCK_OVERHEAD } from \"./rt/common\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  get length(): i32 {\n    ERROR(\"missing implementation: subclasses must implement ArrayBufferView#length\");\n    return unreachable();\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(length = length << alignLog2, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    this.buffer = changetype<ArrayBuffer>(buffer); // retains\n    this.dataStart = buffer;\n    this.byteLength = length;\n  }\n}\n\n@sealed export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (value === null) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(<usize>length, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    return changetype<ArrayBuffer>(buffer); // retains\n  }\n\n  get byteLength(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = __alloc(outSize, idof<ArrayBuffer>());\n    memory.copy(out, changetype<usize>(this) + <usize>begin, outSize);\n    return changetype<ArrayBuffer>(out); // retains\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\n/** Garbage collector interface. */\nexport namespace gc {\n\n  /** Can be set to `false` to disable automatic collection. Defaults to `true`. */\n  export var auto: bool = true;\n\n  /** Performs a full garbage collection cycle. */\n  export function collect(): void {\n    __collect();\n  }\n}\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { BLOCK, BLOCK_OVERHEAD } from \"./rt/common\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ref: usize, superId: u32): bool { // keyword\n  var id = changetype<BLOCK>(ref - BLOCK_OVERHEAD).rtId;\n  var ptr = __rtti_base;\n  if (id <= load<u32>(ptr)) {\n    do if (id == superId) return true;\n    while (id = changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __allocArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var array = __alloc(offsetof<i32[]>(), id);\n  var bufferSize = <usize>length << alignLog2;\n  var buffer = __alloc(bufferSize, idof<ArrayBuffer>());\n  store<usize>(array, __retain(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  store<usize>(array, buffer, offsetof<ArrayBufferView>(\"dataStart\"));\n  store<u32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  if (data) memory.copy(buffer, data, bufferSize);\n  return array;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// @builtin @unsafe\n// export declare function __alloc(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ref: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ref: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __retain(ref: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __release(ref: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ref: usize, cookie: u32): void;\n","// Common error messages for use accross the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n","// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: void): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: void): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): boolean;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: void, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: void): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: void[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: void): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: void): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: void): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: void): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: void): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: void): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: void): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: void): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: void): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: void): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: void): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: void): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: void): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128; // except i64\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma<T>(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms<T>(v1: v128, v2: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i64x2_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i64x2_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms(a: v128, b: v128, c: v128): v128;\n}\n\nexport namespace v8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v16x8 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v32x4 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v64x2 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { ArrayBufferView } from \"./arraybuffer\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureSize(array: usize, minSize: usize, alignLog2: u32): void {\n  var oldCapacity = changetype<ArrayBufferView>(array).byteLength;\n  if (minSize > <usize>oldCapacity >>> alignLog2) {\n    if (minSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    let newCapacity = minSize << alignLog2;\n    let newData = __realloc(oldData, newCapacity); // keeps RC\n    memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    if (newData !== oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n    }\n    store<u32>(array, newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> extends ArrayBufferView {\n  [key: number]: T;\n\n  // Implementing ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `data`) and `dataLength` (equals computed `data.byteLength`).\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? builtin_isArray(value) && value !== null : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    var array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    super(length, alignof<T>());\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    var oldLength = this.length_;\n    if (isManaged<T>()) {\n      if (oldLength > newLength) { // release no longer used refs\n        let dataStart = this.dataStart;\n        let cur = dataStart + (<usize>newLength << alignof<T>());\n        let end = dataStart + (<usize>oldLength << alignof<T>());\n        do __release(load<usize>(cur));\n        while ((cur += sizeof<T>()) < end);\n      } else {\n        ensureSize(changetype<usize>(this), newLength, alignof<T>());\n      }\n    } else {\n      ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    }\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (!fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (predicate(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = this.__unchecked_get(index);\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __unchecked_get(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureSize(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    this.__unchecked_set(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __unchecked_set(index: i32, value: T): void {\n    if (isManaged<T>()) {\n      let offset = this.dataStart + (<usize>index << alignof<T>());\n      let oldRef = load<usize>(offset);\n      if (changetype<usize>(value) != oldRef) {\n        store<usize>(offset, __retain(changetype<usize>(value)));\n        __release(oldRef);\n      }\n    } else {\n      store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var length = this.length_;\n    start = start < 0 ? max(length + start, 0) : min(start, length);\n    end   = end   < 0 ? max(length + end,   0) : min(end,   length);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        let oldRef: usize = load<usize>(dataStart + (<usize>start << alignof<T>()));\n        if (changetype<usize>(value) != oldRef) {\n          store<usize>(dataStart + (<usize>start << alignof<T>()), __retain(changetype<usize>(value)));\n          __release(oldRef);\n        }\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          dataStart + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(dataStart + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length_;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      let dataStart = this.dataStart;\n      while (fromIndex < length) {\n        let elem = load<T>(dataStart + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var dataStart = this.dataStart;\n    while (fromIndex < length) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var dataStart = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    var length = this.length_;\n    var newLength = length + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>length << alignof<T>()), __retain(changetype<usize>(value)));\n    } else {\n      store<T>(this.dataStart + (<usize>length << alignof<T>()), value);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = select(0, other.length_, other === null);\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__allocArray(outLen, alignof<T>(), idof<Array<T>>())); // retains\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, __retain(ref));\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, __retain(ref));\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var len = this.length_;\n\n        end   = min<i32>(end, len);\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    if (isManaged<T>()) {\n      if (from < to && to < (from + count)) { // right to left\n        from += count - 1;\n        to   += count - 1;\n        while (count) {\n          let oldRef: usize = load<usize>(dataStart + (<usize>to << alignof<T>()));\n          let newRef: usize = load<usize>(dataStart + (<usize>from << alignof<T>()));\n          if (newRef != oldRef) {\n            store<usize>(dataStart + (<usize>to << alignof<T>()), __retain(newRef));\n            __release(oldRef);\n          }\n          --from, --to, --count;\n        }\n      } else { // left to right\n        while (count) {\n          let oldRef: usize = load<usize>(dataStart + (<usize>to << alignof<T>()));\n          let newRef: usize = load<usize>(dataStart + (<usize>from << alignof<T>()));\n          if (newRef != oldRef) {\n            store<usize>(dataStart + (<usize>to << alignof<T>()), __retain(newRef));\n            __release(oldRef);\n          }\n          ++from, ++to, --count;\n        }\n      }\n    } else {\n      memory.copy( // is memmove\n        dataStart + (<usize>to << alignof<T>()),\n        dataStart + (<usize>from << alignof<T>()),\n        <usize>count << alignof<T>()\n      );\n    }\n    return this;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var element = load<T>(this.dataStart + (<usize>(--length) << alignof<T>()));\n    this.length_ = length;\n    return element; // no need to retain -> is moved\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var length = this.length_;\n    var out = changetype<Array<U>>(__allocArray(length, alignof<U>(), idof<Array<U>>())); // retains\n    var outStart = out.dataStart;\n    for (let index = 0; index < min(length, this.length_); ++index) {\n      let result = fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this); // retains\n      if (isManaged<U>()) {\n        store<usize>(outStart + (<usize>index << alignof<U>()), __retain(changetype<usize>(result)));\n      } else {\n        store<U>(outStart + (<usize>index << alignof<U>()), result);\n      }\n      // releases result\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__allocArray(0, alignof<T>(), idof<Array<T>>())); // retains\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n      if (fn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = this.length_ - 1; index >= 0; --index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var base = this.dataStart;\n    var element = load<T>(base);\n    var lastIndex = length - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    store<T>(base + (<usize>lastIndex << alignof<T>()), isReference<T>() ? null : 0);\n    this.length_ = lastIndex;\n    return element; // no need to retain -> is moved\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    var newLength = this.length_ + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    var dataStart = this.dataStart;\n    memory.copy(\n      dataStart + sizeof<T>(),\n      dataStart,\n      <usize>(newLength - 1) << alignof<T>()\n    );\n    if (isManaged<T>()) {\n      store<usize>(dataStart, __retain(changetype<usize>(value)));\n    } else {\n      store<T>(dataStart, value);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length_;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var slice = changetype<Array<T>>(__allocArray(length, alignof<T>(), idof<Array<T>>())); // retains\n    var sliceBase = slice.dataStart;\n    var thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>length << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, __retain(ref));\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var length  = this.length_;\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\n    var result = changetype<Array<T>>(__allocArray(deleteCount, alignof<T>(), idof<Array<T>>())); // retains\n    var resultStart = result.dataStart;\n    var thisStart = this.dataStart;\n    var thisBase  = thisStart + (<usize>start << alignof<T>());\n    // no need to retain -> is moved\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (length != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(length - offset) << alignof<T>()\n      );\n    }\n    this.length_ = length - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    var length = this.length_;\n    if (length) {\n      let front = this.dataStart;\n      let back = this.dataStart + (<usize>(length - 1) << alignof<T>());\n      while (front < back) {\n        let temp = load<T>(front);\n        store<T>(front, load<T>(back));\n        store<T>(back, temp);\n        front += sizeof<T>();\n        back -= sizeof<T>();\n      }\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    var length = this.length_;\n    if (length <= 1) return this;\n    var base = this.dataStart;\n    if (length == 2) {\n      let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n      let b: T = load<T>(base); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        store<T>(base, b, sizeof<T>()); // arr[1] = b;\n        store<T>(base, a); // arr[0] = a;\n      }\n      return this;\n    }\n    SORT<T>(base, length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    var dataStart = this.dataStart;\n    var length = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(dataStart, length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(dataStart, length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(dataStart, length, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(dataStart, length, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(dataStart, length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit_impl(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    // automatically visits ArrayBufferView (.buffer) next\n  }\n}\n","// The entry file of your WebAssembly module.\n\nimport { Console, CommandLine } from \"as-wasi\";\n\nexport function _start(): void {\n  // Parse command line arguments\n  let commandLine = new CommandLine();\n  let args: Array<string> = commandLine.all();\n\n  if (args.length < 2) {\n    Console.log('Please pass an argument to echo');\n    return;\n  }\n\n  Console.log(args[1]);\n  \n}\n"]}